<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jokers of Wonders — Stats Lab</title>
  <style>
    :root{--bg:#0b1020;--panel:#121a2f;--muted:#93a3c7;--text:#eef4ff;--line:#263350}
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#0a0f1d,#0e1730);color:var(--text)}
    .app{max-width:1200px;margin:0 auto;padding:18px;display:grid;grid-template-columns:300px 1fr;gap:14px;min-height:100vh}
    @media(max-width:980px){.app{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
    .controls{display:grid;gap:10px}.kpi{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px;margin-bottom:12px}
    .card{background:#0d1528;border:1px solid var(--line);border-radius:12px;padding:10px}.card .k{font-size:12px;color:var(--muted)}.card .v{font-size:24px;font-weight:800;margin-top:3px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}@media(max-width:980px){.grid{grid-template-columns:1fr}}
    table{width:100%;border-collapse:collapse;font-size:13px} th,td{padding:7px 8px;border-bottom:1px solid var(--line);text-align:left}
    th{color:#c4d3f5;font-size:12px;text-transform:uppercase}.hist{display:grid;gap:6px}.bar{display:grid;grid-template-columns:66px 1fr 50px;gap:8px;align-items:center;font-size:12px}
    .track{height:10px;border-radius:999px;background:#0a1222;border:1px solid #29395a;overflow:hidden}.fill{height:100%;background:linear-gradient(90deg,#2dd4bf,#60a5fa)}
    input,select,button{border-radius:10px;border:1px solid #33466e;background:#0d1529;color:var(--text);padding:9px 10px} button{cursor:pointer;background:#16356f;font-weight:700}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel">
      <h1>Jokers of Wonders — Stats Lab</h1>
      <p class="small">Simulatore Monte Carlo coerente con le regole di <code>jow.html</code>, utile a board game designer per tuning bilanciamento (win-rate, condizioni di vittoria, peso delle categorie VP).</p>
      <div class="controls">
        <label>Numero partite <input id="games" type="number" min="1" max="10000" value="1000" /></label>
        <label>Strategia AI A <select id="playerStrategy"><option value="random">Random</option><option value="greedy">Greedy</option><option value="mc" selected>Monte Carlo</option></select></label>
        <label>Strategia AI B <select id="aiStrategy"><option value="random">Random</option><option value="greedy">Greedy</option><option value="mc" selected>Monte Carlo</option></select></label>
        <label>Parte per primo <select id="startMode"><option value="a">AI A</option><option value="b">AI B</option><option value="alternate" selected>Alternato</option></select></label>
        <button id="runBtn">Esegui simulazione</button>
        <div id="status" class="small">Pronto.</div>
      </div>
    </aside>

    <main class="panel">
      <div class="kpi">
        <div class="card"><div class="k">Partite</div><div class="v" id="kGames">0</div></div>
        <div class="card"><div class="k">Win rate AI A</div><div class="v" id="kAWin">0%</div></div>
        <div class="card"><div class="k">Win rate AI B</div><div class="v" id="kBWin">0%</div></div>
        <div class="card"><div class="k">Pareggi</div><div class="v" id="kDraw">0%</div></div>
      </div>

      <div class="grid">
        <section class="card"><h3>Score summary</h3><table><thead><tr><th>Metric</th><th>AI A</th><th>AI B</th></tr></thead><tbody id="scoreTable"></tbody></table></section>
        <section class="card"><h3>Distribuzione margine VP (AI B - AI A)</h3><div id="marginHist" class="hist"></div></section>
      </div>

      <div class="grid" style="margin-top:10px;">
        <section class="card"><h3>Condizioni di vittoria</h3><table><thead><tr><th>Evento</th><th>Frequenza</th></tr></thead><tbody id="eventTable"></tbody></table></section>
        <section class="card"><h3>Breakdown VP medio (regole jow)</h3><table><thead><tr><th>Categoria</th><th>AI A</th><th>AI B</th></tr></thead><tbody id="vpTable"></tbody></table></section>
      </div>
    </main>
  </div>

  <iframe id="coreFrame" src="jow.html" style="display:none"></iframe>

<script>
(function(){
const SUITS=["S","D","H","C"]; const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RANK_VAL=Object.fromEntries(RANKS.map((r,i)=>[r,i+1]));
const MASK13=(1<<13)-1;
const TABLEAU_MODEL={ancient:[{faceDown:false,xs:[2,4]},{faceDown:true,xs:[1.5,2.5,3.5,4.5]},{faceDown:false,xs:[0,1,2,3,4,5,6]},{faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5]},{faceDown:false,xs:[1,2,3,4,5]}],modern:[{faceDown:false,xs:[2,5]},{faceDown:true,xs:[1.5,2.5,3.5,4.5,5.5]},{faceDown:false,xs:[0,1,2,3,4,5,6,7]},{faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5,6.5]},{faceDown:false,xs:[1,2,3,4,5,6]}]};
const runBtn=document.getElementById("runBtn"), statusEl=document.getElementById("status");
const pct=(x,n)=>n?`${(100*x/n).toFixed(1)}%`:"0.0%"; const avg=a=>a.length?a.reduce((x,y)=>x+y,0)/a.length:0;
const fmtPct=v=>`${(100*v).toFixed(1)}%`;
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function makeDeck(){const cards=[];let id=0; for(const s of SUITS){for(const r of RANKS){cards.push({id:id++,suit:s,rank:r});}} return cards;}
function ageOf(rank){return ["A","2","3","4","5","6"].includes(rank)?"ancient":"modern";}
function buildRows(model){let idx=0; return model.map((cfg,row)=>cfg.xs.map((gridX,col)=>({idx:idx++,row,col,gridX})));}
function buildCovering(rows){const total=rows.reduce((a,r)=>a+r.length,0), coveredBy=Array.from({length:total},()=>[]); for(let r=0;r<rows.length-1;r++){const upper=rows[r],lower=rows[r+1],map=new Map(lower.map(s=>[s.gridX,s.idx])); for(const slot of upper){const c1=map.get(slot.gridX-0.5),c2=map.get(slot.gridX+0.5); if(c1!==undefined) coveredBy[slot.idx].push(c1); if(c2!==undefined) coveredBy[slot.idx].push(c2);}} return coveredBy;}
function buildCoveredByRev(coveredBy){const rev=Array.from({length:coveredBy.length},()=>[]); for(let i=0;i<coveredBy.length;i++) for(const c of coveredBy[i]) rev[c].push(i); return rev;}
function buildTableau(age,deck){const model=TABLEAU_MODEL[age], rows=buildRows(model), covering=buildCovering(rows), slots=[]; for(let row=0;row<model.length;row++){for(let col=0;col<model[row].xs.length;col++){slots.push({card:deck.pop(),removed:false,faceDown:model[row].faceDown,row,col});}} return {slots,coveredBy:covering,coveredByRev:buildCoveredByRev(covering)};}
function accessibility(T){const {slots,coveredBy}=T; return slots.map((s,i)=>!s.removed && !(coveredBy[i]||[]).some(c=>!slots[c].removed));}
function flipNew(slots,acc){for(let i=0;i<slots.length;i++) if(!slots[i].removed && slots[i].faceDown && acc[i]) slots[i].faceDown=false;}
function swords(cards){return cards.filter(c=>c.suit==="S").reduce((a,c)=>a+(["A","2","3","4","5"].includes(c.rank)?1:["6","7","8","9","10"].includes(c.rank)?2:3),0);}
function breakthroughCount(cards){const hs=[...new Set(cards.filter(c=>c.suit==="H").map(c=>RANK_VAL[c.rank]))].sort((a,b)=>a-b); if(hs.length<2) return 0; let links=0; for(let i=1;i<hs.length;i++) if(hs[i]===hs[i-1]+1) links++; if(hs.includes(1) && hs.includes(13)) links++; return links;}
function foodVP(cards){const v=cards.filter(c=>c.suit==="C").reduce((a,c)=>a+(c.rank==="A"?1:["J","Q","K"].includes(c.rank)?10:RANK_VAL[c.rank]),0); return Math.floor(v/5);}
function hasCalamityMalus(cards){return cards.filter(c=>c.rank==="K").length>=3;}
function diamondSequences(cards){const owned=new Set(cards.filter(c=>c.suit==="D").map(c=>RANK_VAL[c.rank])); if(owned.size<2) return []; const present=i=>owned.has(i===0?13:i===14?1:i); if(owned.size===13) return [{length:13,high:13}]; const seq=[]; for(let i=1;i<=13;i++){if(!owned.has(i) || present(i-1)) continue; let len=1,cur=i; while(present(cur+1)){len++;cur=cur===13?1:cur+1;if(cur===i)break;} if(len>=2){let high=i; for(let k=0,cc=i;k<len;k++){if(cc===13) high=13; else if(high!==13 && cc>high) high=cc; cc=cc===13?1:cc+1;} seq.push({length:len,high});}} return seq;}
function scoreFromCards(a,b){const sw=[swords(a),swords(b)], tech=[breakthroughCount(a),breakthroughCount(b)], food=[foodVP(a),foodVP(b)], king=[hasCalamityMalus(a)?-5:0,hasCalamityMalus(b)?-5:0]; let vp=[0,0], military=[0,0]; if(sw[0]>sw[1]) military=[8,0]; else if(sw[1]>sw[0]) military=[0,8]; vp[0]+=military[0]+food[0]+tech[0]*2+king[0]; vp[1]+=military[1]+food[1]+tech[1]*2+king[1]; const seqs=[...diamondSequences(a).map(s=>({...s,o:0})),...diamondSequences(b).map(s=>({...s,o:1}))].sort((x,y)=>y.length-x.length||y.high-x.high); const culture=[0,0]; [12,6,3].forEach((v,k)=>{if(seqs[k]){vp[seqs[k].o]+=v; culture[seqs[k].o]+=v;}}); return {vp,military,food,techVP:[tech[0]*2,tech[1]*2],culture,kingPenalty:king,swords:sw,breakthrough:tech};}
function checkSupremacy(S){const f0=S.players[0].feat, f1=S.players[1].feat; if(f0.hLinks>=7) return {winner:0,reason:"Supremazia Tecnologica (7+ coppie Hearts)"}; if(f1.hLinks>=7) return {winner:1,reason:"Supremazia Tecnologica (7+ coppie Hearts)"}; if(f0.sw-f1.sw>=10) return {winner:0,reason:"Supremazia Militare"}; if(f1.sw-f0.sw>=10) return {winner:1,reason:"Supremazia Militare"}; return null;}
function legalMoves(S){const acc=accessibility(S.tableau), res=[]; for(let i=0;i<S.tableau.slots.length;i++){const s=S.tableau.slots[i]; if(acc[i] && !s.removed && !s.faceDown) res.push(i);} return res;}
function ucbSelect(stats,total,c=0.9){
 let bestIdx=null,best=-Infinity;
 for(const [idx,st] of stats.entries()){
  if(st.n===0) return idx;
  const mean=st.w/st.n;
  const ucb=mean+c*Math.sqrt(Math.log(total)/st.n);
  if(ucb>best){best=ucb;bestIdx=idx;}
 }
 return bestIdx;
}
function bitOfRank(rank){return 1<<(RANK_VAL[rank]-1);}
function popcount13(x){x>>>=0; let c=0; while(x){x&=x-1;c++;} return c;}
function heartLinksFromMask(mask){mask&=MASK13; const adj=popcount13(mask&(mask<<1)); const wrap=((mask&1)&&(mask&(1<<12)))?1:0; return adj+wrap;}
function diamondAdjFromMask(mask){mask&=MASK13; const rot=((mask<<1)&MASK13)|(mask>>>12); return popcount13(mask&rot);}
function swordValue(card){const v=RANK_VAL[card.rank]; return (v<=5)?1:(v<=10)?2:3;}
function clubValue(card){if(card.rank==="A") return 1; if(card.rank==="J"||card.rank==="Q"||card.rank==="K") return 10; return RANK_VAL[card.rank];}
function kingRiskFromCount(k){if(k>=3) return -3; if(k===2) return -0.6; return 0;}
function updateFeat(feat,card){
 if(card.suit==="S") feat.sw+=swordValue(card);
 if(card.suit==="H"){feat.hMask|=bitOfRank(card.rank); feat.hLinks=heartLinksFromMask(feat.hMask);}
 if(card.suit==="C") feat.cSum+=clubValue(card);
 if(card.suit==="D"){feat.dMask|=bitOfRank(card.rank); feat.dAdj=diamondAdjFromMask(feat.dMask);}
 if(card.rank==="K") feat.kCount+=1;
}
function staticTakeValue(S,player,card){
 const f=S.players[player].feat;
 const dSw=(card.suit==="S")?swordValue(card):0;
 let dBt=0;
 if(card.suit==="H"){
  const nm=(f.hMask|bitOfRank(card.rank))&MASK13;
  dBt=heartLinksFromMask(nm)-f.hLinks;
 }
 let dFood=0;
 if(card.suit==="C"){
  const before=Math.floor(f.cSum/5);
  const after=Math.floor((f.cSum+clubValue(card))/5);
  dFood=after-before;
 }
 let dDia=0;
 if(card.suit==="D"){
  const nm=(f.dMask|bitOfRank(card.rank))&MASK13;
  dDia=diamondAdjFromMask(nm)-f.dAdj;
 }
 const oldKR=kingRiskFromCount(f.kCount);
 const newKR=kingRiskFromCount(f.kCount+(card.rank==="K"?1:0));
 const dKing=newKR-oldKR;
 return dSw*1.2+dBt*1.6+dFood*1.0+dDia*0.45+dKing*1.4;
}
function cheapEvalTake(S,player,idx){
 const slot=S.tableau.slots[idx]; if(!slot || slot.removed || slot.faceDown) return -Infinity;
 const card=slot.card;
 const me=S.players[player].feat, opp=S.players[1-player].feat;
 const dSw=(card.suit==="S")?swordValue(card):0;
 let dBt=0;
 if(card.suit==="H"){
  const nm=(me.hMask|bitOfRank(card.rank))&MASK13;
  dBt=heartLinksFromMask(nm)-me.hLinks;
 }
 let dFood=0;
 if(card.suit==="C"){
  const before=Math.floor(me.cSum/5);
  const after=Math.floor((me.cSum+clubValue(card))/5);
  dFood=after-before;
 }
 let dDia=0;
 if(card.suit==="D"){
  const nm=(me.dMask|bitOfRank(card.rank))&MASK13;
  dDia=diamondAdjFromMask(nm)-me.dAdj;
 }
 const oldKR=kingRiskFromCount(me.kCount);
 const newKR=kingRiskFromCount(me.kCount+(card.rank==="K"?1:0));
 const dKing=newKR-oldKR;
 const deny=(card.suit==="S"?0.2:0)+(card.suit==="H"?0.15:0), pressure=Math.max(0,opp.sw-me.sw-5)*0.05;
 const baseScore=dSw*1.2+dBt*1.6+dFood*1.0+dDia*0.45+dKing*1.4+deny+pressure;
 let revealBonus=0;
 const rev=S.tableau.coveredByRev?.[idx]||[];
 for(const upperIdx of rev){
  const upper=S.tableau.slots[upperIdx];
  if(!upper || upper.removed) continue;
  const blockers=S.tableau.coveredBy[upperIdx]||[];
  const becomesAccessible=blockers.every(b=>b===idx || S.tableau.slots[b].removed);
  if(!becomesAccessible) continue;
  const w=upper.faceDown?0.35:0.18;
  revealBonus+=w*staticTakeValue(S,player,upper.card);
 }
 return baseScore+revealBonus;
}
function choosePlayoutMove(S,eps=0.2){
 const moves=legalMoves(S); if(!moves.length) return null;
 if(Math.random()<eps) return moves[Math.floor(Math.random()*moves.length)];
 let best=moves[0],bestV=-Infinity; for(const idx of moves){const v=cheapEvalTake(S,S.current,idx); if(v>bestV){bestV=v;best=idx;}} return best;
}
function shouldUseJokerInPlayout(S){if(!(S.players[S.current].joker && S.picksLeftThisTurn===1)) return false; const moves=legalMoves(S); if(moves.length<2) return false; const vals=moves.map(i=>cheapEvalTake(S,S.current,i)).sort((a,b)=>b-a); return vals[1]>0.6;}
function cloneState(S){return {age:S.age,current:S.current,ended:S.ended,nextAgeFirst:S.nextAgeFirst,picksLeftThisTurn:S.picksLeftThisTurn,modernSwapStillAvailable:S.modernSwapStillAvailable,players:S.players.map(p=>({cards:p.cards.slice(),joker:p.joker,feat:{...p.feat}})),tableau:{slots:S.tableau.slots.map(s=>({...s})),coveredBy:S.tableau.coveredBy,coveredByRev:S.tableau.coveredByRev},decks:{ancient:S.decks.ancient.slice(),modern:S.decks.modern.slice()},events:{jokerDouble:S.events.jokerDouble?S.events.jokerDouble.slice():[0,0],modernSwap:S.events.modernSwap||0}};}
function finalReward(S,perspective){if(S.winner!==undefined) return S.winner===perspective?1:0; const sc=scoreFromCards(S.players[0].cards,S.players[1].cards).vp; if(sc[perspective]>sc[1-perspective]) return 1; if(sc[perspective]===sc[1-perspective]) return 0.5; return 0;}
function chooseModernSwap(S,nextFirst){
 const second=1-nextFirst; if(!S.players[second].joker) return nextFirst;
 const noSwap=cloneState(S); noSwap.age="modern"; noSwap.current=nextFirst; noSwap.picksLeftThisTurn=1; noSwap.tableau=buildTableau("modern",noSwap.decks.modern); noSwap.modernSwapStillAvailable=true;
 const swap=cloneState(S); swap.players[second].joker=false; swap.age="modern"; swap.current=second; swap.picksLeftThisTurn=1; swap.tableau=buildTableau("modern",swap.decks.modern); swap.modernSwapStillAvailable=true;
 let evNo=0,evYes=0; for(let i=0;i<4;i++){evNo+=randomPlayout(cloneState(noSwap),second); evYes+=randomPlayout(cloneState(swap),second);} evNo/=4; evYes/=4;
 if(evYes>evNo+0.03){S.players[second].joker=false; S.events.modernSwap++; return second;} return nextFirst;
}
function advanceAge(S){if(S.age==="ancient"){const start=chooseModernSwap(S,S.nextAgeFirst); S.modernSwapStillAvailable=true; S.current=start; S.picksLeftThisTurn=1; S.age="modern"; S.tableau=buildTableau("modern",S.decks.modern); return;} S.ended=true;}
function applyTake(S,idx){const slot=S.tableau.slots[idx]; slot.removed=true; S.players[S.current].cards.push(slot.card); updateFeat(S.players[S.current].feat,slot.card); S.picksLeftThisTurn=Math.max(0,S.picksLeftThisTurn-1); flipNew(S.tableau.slots,accessibility(S.tableau)); const sup=checkSupremacy(S); if(sup){S.ended=true; S.winBy=sup.reason; S.winner=sup.winner; return;} if(S.age==="modern" && S.modernSwapStillAvailable) S.modernSwapStillAvailable=false; if(S.tableau.slots.every(s=>s.removed)) advanceAge(S); else if(S.picksLeftThisTurn<=0){S.picksLeftThisTurn=1; S.current=1-S.current;}}
function randomPlayout(S,perspective=S.current){let guard=600; while(!S.ended && guard-->0){const moves=legalMoves(S); if(!moves.length){S.picksLeftThisTurn=1; S.current=1-S.current; continue;} if(shouldUseJokerInPlayout(S)){S.players[S.current].joker=false;S.picksLeftThisTurn=2;} const idx=choosePlayoutMove(S,0.2); if(idx===null){S.picksLeftThisTurn=1;S.current=1-S.current;continue;} applyTake(S,idx);} return finalReward(S,perspective);}
function chooseMoveUcb(S,moves,K=3){
 const ordered=moves.map(i=>({idx:i,v:cheapEvalTake(S,S.current,i)})).sort((a,b)=>b.v-a.v);
 const cand=ordered.slice(0,Math.min(K,ordered.length)).map(x=>x.idx);
 if(moves.length>cand.length && Math.random()<0.1){const extra=moves.filter(m=>!cand.includes(m)); if(extra.length) cand.push(extra[Math.floor(Math.random()*extra.length)]);}
 const left=S.tableau.slots.reduce((n,s)=>n+(!s.removed?1:0),0);
 let T=S.age==="ancient"?8:12; if(left<=10) T=18; if(left<=6) T=24;
 const stats=new Map(cand.map(i=>[i,{n:0,w:0}]));
 let total=0;
 for(let t=0;t<T;t++){
  const idx=ucbSelect(stats,++total,0.9);
  const C=cloneState(S); applyTake(C,idx);
  const r=randomPlayout(C,S.current);
  const st=stats.get(idx); st.n++; st.w+=r;
 }
 let best=cand[0],bestV=-Infinity;
 for(const [idx,st] of stats.entries()){const v=st.w/Math.max(1,st.n); if(v>bestV){bestV=v;best=idx;}}
 return best;
}
function bestSingleValue(S,moves){
 let best=-Infinity;
 for(const i of moves) best=Math.max(best,cheapEvalTake(S,S.current,i));
 return best;
}
function bestTwoPickValue(S,moves){
 const p=S.current;
 const firstCand=moves
  .map(i=>({i,v:cheapEvalTake(S,p,i)}))
  .sort((a,b)=>b.v-a.v)
  .slice(0,3);

 let best=-Infinity;
 for(const {i:first,v:v1} of firstCand){
  const C=cloneState(S);
  C.players[p].joker=false;
  C.picksLeftThisTurn=2;

  applyTake(C,first);

  const m2=legalMoves(C);
  let v2=0;
  if(m2.length){
   v2=-Infinity;
   for(const j of m2) v2=Math.max(v2,cheapEvalTake(C,p,j));
   if(!isFinite(v2)) v2=0;
  }

  best=Math.max(best,v1+0.9*v2);
 }
 return best;
}
function remainingCardsThisAge(S){
 let n=0;
 for(const sl of S.tableau.slots) if(!sl.removed) n++;
 return n;
}
function jokerReservePenalty(S,player){
 if(S.age!=="ancient") return 0;

 const left=remainingCardsThisAge(S);
 const t=Math.min(1,Math.max(0,left/18));
 const second=1-S.nextAgeFirst;

 // Valore-opportunità del Joker in Antica: tenerlo per lo swap d'ordine in Moderna.
 // Penalità base per tutti + extra per chi rischia di iniziare secondo la Moderna.
 let penalty=0.40+0.70*t;
 if(player===second) penalty+=0.35+0.45*t;
 return penalty;
}
function canForceSupremacyWithTwoPicks(S,moves){
 const p=S.current;

 const firstCand=moves
  .map(i=>({i,v:cheapEvalTake(S,p,i)}))
  .sort((a,b)=>b.v-a.v)
  .slice(0,3);

 for(const {i:first} of firstCand){
  const C=cloneState(S);
  C.players[p].joker=false;
  C.picksLeftThisTurn=2;

  applyTake(C,first);
  if(C.ended && C.winner===p) return true;

  const m2=legalMoves(C);
  if(!m2.length) continue;

  let best2=m2[0],bestV=-Infinity;
  for(const j of m2){
   const v=cheapEvalTake(C,p,j);
   if(v>bestV){bestV=v; best2=j;}
  }
  applyTake(C,best2);
  if(C.ended && C.winner===p) return true;
 }
 return false;
}
function maybeUseJokerNow(S,moves){
 if(!(S.players[S.current].joker && S.picksLeftThisTurn===1 && moves.length>=2)) return false;

 if(canForceSupremacyWithTwoPicks(S,moves)) return true;

 // In Antica evitiamo l'uso precoce del Joker salvo chiusure immediate: 
 // aumenta la probabilità di conservarlo per lo swap in Moderna.
 if(S.age==="ancient" && remainingCardsThisAge(S)>4) return false;

 const v1=bestSingleValue(S,moves);
 const v2=bestTwoPickValue(S,moves);

 const penalty=jokerReservePenalty(S,S.current);
 const baseThreshold=0.35;

 return v2>v1+baseThreshold+penalty;
}
function chooseMove(S,strategy){const moves=legalMoves(S); if(!moves.length) return null; if(strategy==="random") return moves[Math.floor(Math.random()*moves.length)]; if(strategy==="greedy"){let best=moves[0],bestV=-Infinity; for(const idx of moves){const v=cheapEvalTake(S,S.current,idx); if(v>bestV){bestV=v;best=idx;}} return best;}
 if(maybeUseJokerNow(S,moves)){S.players[S.current].joker=false; S.picksLeftThisTurn=2; S.events.jokerDouble[S.current]++;}
 return chooseMoveUcb(S,legalMoves(S),3);}
function simulateOne(startPlayer,strA,strB){const base=shuffle(makeDeck()); const ancient=shuffle(base.filter(c=>ageOf(c.rank)==="ancient")); const modern=shuffle(base.filter(c=>ageOf(c.rank)==="modern"));
 const S={age:"ancient",nextAgeFirst:1-startPlayer,current:startPlayer,ended:false,decks:{ancient,modern},tableau:buildTableau("ancient",ancient),players:[{cards:[],joker:true,feat:{sw:0,hMask:0,hLinks:0,cSum:0,dMask:0,dAdj:0,kCount:0}},{cards:[],joker:true,feat:{sw:0,hMask:0,hLinks:0,cSum:0,dMask:0,dAdj:0,kCount:0}}],picksLeftThisTurn:1,modernSwapStillAvailable:false,events:{jokerDouble:[0,0],modernSwap:0}};
 let guard=1000; while(!S.ended && guard-->0){const strat=S.current===0?strA:strB; const mv=chooseMove(S,strat); if(mv===null){S.picksLeftThisTurn=1; S.current=1-S.current; continue;} applyTake(S,mv);} const score=scoreFromCards(S.players[0].cards,S.players[1].cards);
 const vpA=score.vp[0], vpB=score.vp[1]; const winner=S.winner!==undefined?(S.winner===0?"a":"b"):(vpA===vpB?"draw":(vpA>vpB?"a":"b")); const winBy=S.winBy || (winner==="draw"?"Pareggio punti":"Punti");
 return {vpA,vpB,margin:vpB-vpA,winner,winBy,score,events:S.events};}
function renderRows(tbody,rows){tbody.innerHTML=rows.map(r=>`<tr><td>${r[0]}</td><td>${r[1]}</td>${r[2]!==undefined?`<td>${r[2]}</td>`:""}</tr>`).join("");}
function renderHistogram(margins){const buckets=new Map(); for(let x=-20;x<=20;x+=4) buckets.set(`${x}..${x+3}`,0); buckets.set("<=-21",0); buckets.set(">=21",0); for(const m of margins){if(m<=-21)buckets.set("<=-21",buckets.get("<=-21")+1); else if(m>=21)buckets.set(">=21",buckets.get(">=21")+1); else {const b=Math.floor((m+20)/4),s=-20+b*4,key=`${s}..${s+3}`; buckets.set(key,buckets.get(key)+1);}} const total=Math.max(1,margins.length),maxN=Math.max(1,...buckets.values()); document.getElementById("marginHist").innerHTML=[...buckets.entries()].map(([k,v])=>`<div class="bar"><div>${k}</div><div class="track"><div class="fill" style="width:${Math.round(100*v/maxN)}%"></div></div><div>${(100*v/total).toFixed(1)}%</div></div>`).join("");}
async function runBatch(){const n=Math.max(1,Math.min(10000,Number(document.getElementById("games").value)||1000)); const sA=document.getElementById("playerStrategy").value, sB=document.getElementById("aiStrategy").value, sm=document.getElementById("startMode").value;
 runBtn.disabled=true; const out=[]; let lastUiTick=performance.now();
 for(let i=0;i<n;i++){
  const start=sm==="alternate"?(i%2):sm==="a"?0:1;
  out.push(simulateOne(start,sA,sB));
  const done=i+1;
  const now=performance.now();
  if(done===n || now-lastUiTick>=33){
   statusEl.textContent=`Simulazione in corso: ${done}/${n}`;
   lastUiTick=now;
   await new Promise(r=>setTimeout(r,0));
  }
 }
 const aWin=out.filter(x=>x.winner==="a").length,bWin=out.filter(x=>x.winner==="b").length,draw=out.length-aWin-bWin;
 const nonDraw=Math.max(1,aWin+bWin), pB=bWin/nonDraw, pA=aWin/nonDraw;
 const se=Math.sqrt(0.25/nonDraw), ci95=1.96*se, delta=pB-pA;
 const significance=Math.abs(delta)<=ci95?"Differenza compatibile con varianza statistica":"Differenza oltre la banda 95% (verificare con più partite)";
 const pointsOnly=out.filter(x=>x.winBy==="Punti"||x.winBy==="Pareggio punti");
 document.getElementById("kGames").textContent=String(out.length); document.getElementById("kAWin").textContent=pct(aWin,out.length); document.getElementById("kBWin").textContent=pct(bWin,out.length); document.getElementById("kDraw").textContent=pct(draw,out.length);
 const margins=out.map(x=>x.margin); renderHistogram(margins);
 renderRows(document.getElementById("scoreTable"),[["VP medi",avg(out.map(x=>x.vpA)).toFixed(2),avg(out.map(x=>x.vpB)).toFixed(2)],["VP mediani",out.map(x=>x.vpA).sort((a,b)=>a-b)[Math.floor(out.length/2)],out.map(x=>x.vpB).sort((a,b)=>a-b)[Math.floor(out.length/2)]],["Margine medio (B-A)",avg(margins).toFixed(2),"—"],["Vittorie per Supremazia",pct(out.filter(x=>x.winBy.includes("Supremazia") && x.winner==="a").length,out.length),pct(out.filter(x=>x.winBy.includes("Supremazia") && x.winner==="b").length,out.length)]]);
 renderRows(document.getElementById("eventTable"),[["Supremazia Tecnologica",pct(out.filter(x=>x.winBy.includes("Supremazia Tecnologica")).length,out.length)],["Supremazia Militare",pct(out.filter(x=>x.winBy==="Supremazia Militare").length,out.length)],["Partite ai punti",pct(pointsOnly.length,out.length)],["Joker doppia presa AI A",avg(out.map(x=>x.events.jokerDouble[0])).toFixed(2)+" / partita"],["Joker doppia presa AI B",avg(out.map(x=>x.events.jokerDouble[1])).toFixed(2)+" / partita"],["Swap ordine Età Moderna",pct(out.filter(x=>x.events.modernSwap>0).length,out.length)],["Win-rate AI A/B (senza pareggi)",`${fmtPct(pA)} / ${fmtPct(pB)}`],["Delta B-A e banda 95%",`${fmtPct(delta)} (±${fmtPct(ci95)})`],["Lettura statistica",significance]]);
 renderRows(document.getElementById("vpTable"),[["VP Militari (♠)",avg(pointsOnly.map(x=>x.score.military[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.military[1])).toFixed(2)],["VP Cultura (♦)",avg(pointsOnly.map(x=>x.score.culture[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.culture[1])).toFixed(2)],["VP Tecnologia (♥)",avg(pointsOnly.map(x=>x.score.techVP[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.techVP[1])).toFixed(2)],["VP Cibo (♣)",avg(pointsOnly.map(x=>x.score.food[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.food[1])).toFixed(2)],["Malus calamità (>=3 Re)",avg(pointsOnly.map(x=>x.score.kingPenalty[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.kingPenalty[1])).toFixed(2)],["Frequenza calamità (>=3 Re | solo partite ai punti)",`${pct(pointsOnly.filter(x=>x.score.kingPenalty[0]<0).length,pointsOnly.length)} (n=${pointsOnly.length})`,`${pct(pointsOnly.filter(x=>x.score.kingPenalty[1]<0).length,pointsOnly.length)} (n=${pointsOnly.length})`],["Swords medi",avg(pointsOnly.map(x=>x.score.swords[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.swords[1])).toFixed(2)],["Breakthrough medi",avg(pointsOnly.map(x=>x.score.breakthrough[0])).toFixed(2),avg(pointsOnly.map(x=>x.score.breakthrough[1])).toFixed(2)]]);
 statusEl.textContent=`Completato: ${n} partite.`; runBtn.disabled=false;}
runBtn.addEventListener("click",runBatch);
statusEl.textContent="Pronto. Core statistico allineato a jow.html (iframe su jow.html).";
})();
</script>
</body>
</html>
