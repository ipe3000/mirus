<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jokers of Wonders — Stats Lab</title>
  <style>
    :root{--bg:#0b1020;--panel:#121a2f;--muted:#93a3c7;--text:#eef4ff;--line:#263350}
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#0a0f1d,#0e1730);color:var(--text)}
    .app{max-width:1200px;margin:0 auto;padding:18px;display:grid;grid-template-columns:300px 1fr;gap:14px;min-height:100vh}
    @media(max-width:980px){.app{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
    .controls{display:grid;gap:10px}.kpi{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px;margin-bottom:12px}
    .card{background:#0d1528;border:1px solid var(--line);border-radius:12px;padding:10px}.card .k{font-size:12px;color:var(--muted)}.card .v{font-size:24px;font-weight:800;margin-top:3px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}@media(max-width:980px){.grid{grid-template-columns:1fr}}
    table{width:100%;border-collapse:collapse;font-size:13px} th,td{padding:7px 8px;border-bottom:1px solid var(--line);text-align:left}
    th{color:#c4d3f5;font-size:12px;text-transform:uppercase}.hist{display:grid;gap:6px}.bar{display:grid;grid-template-columns:66px 1fr 50px;gap:8px;align-items:center;font-size:12px}
    .track{height:10px;border-radius:999px;background:#0a1222;border:1px solid #29395a;overflow:hidden}.fill{height:100%;background:linear-gradient(90deg,#2dd4bf,#60a5fa)}
    input,select,button{border-radius:10px;border:1px solid #33466e;background:#0d1529;color:var(--text);padding:9px 10px} button{cursor:pointer;background:#16356f;font-weight:700}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel">
      <h1>Jokers of Wonders — Stats Lab</h1>
      <p class="small">Simulatore Monte Carlo coerente con le regole di <code>jow.html</code>, utile a board game designer per tuning bilanciamento (win-rate, condizioni di vittoria, peso delle categorie VP).</p>
      <div class="controls">
        <label>Numero partite <input id="games" type="number" min="1" max="10000" value="1000" /></label>
        <label>Strategia AI A <select id="playerStrategy"><option value="random">Random</option><option value="greedy">Greedy</option><option value="mc" selected>Monte Carlo</option></select></label>
        <label>Strategia AI B <select id="aiStrategy"><option value="random">Random</option><option value="greedy">Greedy</option><option value="mc" selected>Monte Carlo</option></select></label>
        <label>Parte per primo <select id="startMode"><option value="a">AI A</option><option value="b">AI B</option><option value="alternate" selected>Alternato</option></select></label>
        <button id="runBtn">Esegui simulazione</button>
        <div id="status" class="small">Pronto.</div>
      </div>
    </aside>

    <main class="panel">
      <div class="kpi">
        <div class="card"><div class="k">Partite</div><div class="v" id="kGames">0</div></div>
        <div class="card"><div class="k">Win rate AI A</div><div class="v" id="kAWin">0%</div></div>
        <div class="card"><div class="k">Win rate AI B</div><div class="v" id="kBWin">0%</div></div>
        <div class="card"><div class="k">Pareggi</div><div class="v" id="kDraw">0%</div></div>
      </div>

      <div class="grid">
        <section class="card"><h3>Score summary</h3><table><thead><tr><th>Metric</th><th>AI A</th><th>AI B</th></tr></thead><tbody id="scoreTable"></tbody></table></section>
        <section class="card"><h3>Distribuzione margine VP (AI B - AI A)</h3><div id="marginHist" class="hist"></div></section>
      </div>

      <div class="grid" style="margin-top:10px;">
        <section class="card"><h3>Condizioni di vittoria</h3><table><thead><tr><th>Evento</th><th>Frequenza</th></tr></thead><tbody id="eventTable"></tbody></table></section>
        <section class="card"><h3>Breakdown VP medio (regole jow)</h3><table><thead><tr><th>Categoria</th><th>AI A</th><th>AI B</th></tr></thead><tbody id="vpTable"></tbody></table></section>
      </div>
    </main>
  </div>

  <iframe id="coreFrame" src="jow.html" style="display:none"></iframe>

<script>
(function(){
const SUITS=["S","D","H","C"]; const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RANK_VAL=Object.fromEntries(RANKS.map((r,i)=>[r,i+1]));
const TABLEAU_MODEL={ancient:[{faceDown:false,xs:[2,4]},{faceDown:true,xs:[1.5,2.5,3.5,4.5]},{faceDown:false,xs:[0,1,2,3,4,5,6]},{faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5]},{faceDown:false,xs:[1,2,3,4,5]}],modern:[{faceDown:false,xs:[2,5]},{faceDown:true,xs:[1.5,2.5,3.5,4.5,5.5]},{faceDown:false,xs:[0,1,2,3,4,5,6,7]},{faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5,6.5]},{faceDown:false,xs:[1,2,3,4,5,6]}]};
const runBtn=document.getElementById("runBtn"), statusEl=document.getElementById("status");
const pct=(x,n)=>n?`${(100*x/n).toFixed(1)}%`:"0.0%"; const avg=a=>a.length?a.reduce((x,y)=>x+y,0)/a.length:0;
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function makeDeck(){const cards=[];let id=0; for(const s of SUITS){for(const r of RANKS){cards.push({id:id++,suit:s,rank:r});}} return cards;}
function ageOf(rank){return ["A","2","3","4","5","6"].includes(rank)?"ancient":"modern";}
function buildRows(model){let idx=0; return model.map((cfg,row)=>cfg.xs.map((gridX,col)=>({idx:idx++,row,col,gridX})));}
function buildCovering(rows){const total=rows.reduce((a,r)=>a+r.length,0), coveredBy=Array.from({length:total},()=>[]); for(let r=0;r<rows.length-1;r++){const upper=rows[r],lower=rows[r+1],map=new Map(lower.map(s=>[s.gridX,s.idx])); for(const slot of upper){const c1=map.get(slot.gridX-0.5),c2=map.get(slot.gridX+0.5); if(c1!==undefined) coveredBy[slot.idx].push(c1); if(c2!==undefined) coveredBy[slot.idx].push(c2);}} return coveredBy;}
function buildTableau(age,deck){const model=TABLEAU_MODEL[age], rows=buildRows(model), covering=buildCovering(rows), slots=[]; for(let row=0;row<model.length;row++){for(let col=0;col<model[row].xs.length;col++){slots.push({card:deck.pop(),removed:false,faceDown:model[row].faceDown,row,col});}} return {slots,coveredBy:covering};}
function accessibility(T){const {slots,coveredBy}=T; return slots.map((s,i)=>!s.removed && !(coveredBy[i]||[]).some(c=>!slots[c].removed));}
function flipNew(slots,acc){for(let i=0;i<slots.length;i++) if(!slots[i].removed && slots[i].faceDown && acc[i]) slots[i].faceDown=false;}
function swords(cards){return cards.filter(c=>c.suit==="S").reduce((a,c)=>a+(["A","2","3","4","5"].includes(c.rank)?1:["6","7","8","9","10"].includes(c.rank)?2:3),0);}
function breakthroughCount(cards){const hs=[...new Set(cards.filter(c=>c.suit==="H").map(c=>RANK_VAL[c.rank]))].sort((a,b)=>a-b); let links=0; for(let i=1;i<hs.length;i++) if(hs[i]===hs[i-1]+1) links++; return links;}
function foodVP(cards){const v=cards.filter(c=>c.suit==="C").reduce((a,c)=>a+(c.rank==="A"?1:["J","Q","K"].includes(c.rank)?10:RANK_VAL[c.rank]),0); return Math.floor(v/5);}
function hasFourKings(cards){return ["S","D","H","C"].every(s=>cards.some(c=>c.suit===s && c.rank==="K"));}
function diamondSequences(cards){const owned=new Set(cards.filter(c=>c.suit==="D").map(c=>RANK_VAL[c.rank])); if(owned.size<2) return []; const present=i=>owned.has(i===0?13:i===14?1:i); if(owned.size===13) return [{length:13,high:13}]; const seq=[]; for(let i=1;i<=13;i++){if(!owned.has(i) || present(i-1)) continue; let len=1,cur=i; while(present(cur+1)){len++;cur=cur===13?1:cur+1;if(cur===i)break;} if(len>=2){let high=i; for(let k=0,cc=i;k<len;k++){if(cc===13) high=13; else if(high!==13 && cc>high) high=cc; cc=cc===13?1:cc+1;} seq.push({length:len,high});}} return seq;}
function scoreFromCards(a,b){const sw=[swords(a),swords(b)], tech=[breakthroughCount(a),breakthroughCount(b)], food=[foodVP(a),foodVP(b)], king=[hasFourKings(a)?-5:0,hasFourKings(b)?-5:0]; let vp=[0,0], military=[0,0]; if(sw[0]>sw[1]) military=[5,0]; else if(sw[1]>sw[0]) military=[0,5]; vp[0]+=military[0]+food[0]+tech[0]*2+king[0]; vp[1]+=military[1]+food[1]+tech[1]*2+king[1]; const seqs=[...diamondSequences(a).map(s=>({...s,o:0})),...diamondSequences(b).map(s=>({...s,o:1}))].sort((x,y)=>y.length-x.length||y.high-x.high); const culture=[0,0]; [12,6,3].forEach((v,k)=>{if(seqs[k]){vp[seqs[k].o]+=v; culture[seqs[k].o]+=v;}}); return {vp,military,food,techVP:[tech[0]*2,tech[1]*2],culture,kingPenalty:king,swords:sw,breakthrough:tech};}
function checkSupremacy(S){const sw=S.players.map(p=>swords(p.cards)), tp=S.players.map(p=>breakthroughCount(p.cards)); if(tp[0]>=5) return {winner:0,reason:"Supremazia Tecnologica (5+ Heart pairs)"}; if(tp[1]>=5) return {winner:1,reason:"Supremazia Tecnologica (5+ Heart pairs)"}; if(sw[0]-sw[1]>10) return {winner:0,reason:"Supremazia Militare"}; if(sw[1]-sw[0]>10) return {winner:1,reason:"Supremazia Militare"}; return null;}
function legalMoves(S){const acc=accessibility(S.tableau), res=[]; for(let i=0;i<S.tableau.slots.length;i++){const s=S.tableau.slots[i]; if(acc[i] && !s.removed && !s.faceDown) res.push(i);} return res;}
function cloneState(S){return {age:S.age,current:S.current,ended:S.ended,nextAgeFirst:S.nextAgeFirst,picksLeftThisTurn:S.picksLeftThisTurn,modernSwapStillAvailable:S.modernSwapStillAvailable,players:S.players.map(p=>({cards:p.cards.slice(),joker:p.joker})),tableau:{slots:S.tableau.slots.map(s=>({...s})),coveredBy:S.tableau.coveredBy.map(a=>a.slice())},decks:{ancient:S.decks.ancient.slice(),modern:S.decks.modern.slice()},events:{...S.events}};}
function advanceAge(S){if(S.age==="ancient"){const second=1-S.nextAgeFirst; S.modernSwapStillAvailable=true; if(S.players[second].joker){S.players[second].joker=false; S.current=second; S.events.modernSwap++;} else S.current=S.nextAgeFirst; S.picksLeftThisTurn=1; S.age="modern"; S.tableau=buildTableau("modern",S.decks.modern); return;} S.ended=true;}
function applyTake(S,idx){const slot=S.tableau.slots[idx]; slot.removed=true; S.players[S.current].cards.push(slot.card); S.picksLeftThisTurn=Math.max(0,S.picksLeftThisTurn-1); flipNew(S.tableau.slots,accessibility(S.tableau)); const sup=checkSupremacy(S); if(sup){S.ended=true; S.winBy=sup.reason; S.winner=sup.winner; return;} if(S.age==="modern" && S.modernSwapStillAvailable) S.modernSwapStillAvailable=false; if(S.tableau.slots.every(s=>s.removed)) advanceAge(S); else if(S.picksLeftThisTurn<=0){S.picksLeftThisTurn=1; S.current=1-S.current;}}
function randomPlayout(S){let guard=600; while(!S.ended && guard-->0){const moves=legalMoves(S); if(!moves.length){S.picksLeftThisTurn=1; S.current=1-S.current; continue;} if(S.players[S.current].joker && S.picksLeftThisTurn===1 && Math.random()<0.12){S.players[S.current].joker=false;S.picksLeftThisTurn=2;} const idx=moves[Math.floor(Math.random()*moves.length)]; applyTake(S,idx);} if(S.winner!==undefined) return S.winner; const sc=scoreFromCards(S.players[0].cards,S.players[1].cards).vp; return sc[0]===sc[1]?2:(sc[0]>sc[1]?0:1);}
function remainingOpenCards(S){return S.tableau.slots.reduce((n,s)=>n+(!s.removed?1:0),0);}
function monteCarloIters(S,movesCount){
 let iters=44;
 if(S.age==="modern") iters+=14;
 const left=remainingOpenCards(S);
 if(left<=12) iters+=20;
 if(left<=7) iters+=28;
 if(movesCount<=5) iters=Math.round(iters*1.2);
 if(movesCount<=3) iters=Math.round(iters*1.25);
 return Math.max(44,iters);
}
function evalMove(S,idx,strategy,movesCount){
 if(strategy==="random") return Math.random();
 if(strategy==="greedy"){
  const C=cloneState(S); applyTake(C,idx);
  const sc=scoreFromCards(C.players[0].cards,C.players[1].cards).vp;
  return S.current===0?sc[0]-sc[1]:sc[1]-sc[0];
 }
 const iters=monteCarloIters(S,movesCount);
 let score=0;
 for(let i=0;i<iters;i++){
  const C=cloneState(S); applyTake(C,idx);
  const w=randomPlayout(C);
  score += (w===S.current?1:w===2?0.5:0);
 }
 return score/iters;
}
function chooseMove(S,strategy){const moves=legalMoves(S); if(!moves.length) return null; if(S.players[S.current].joker && S.picksLeftThisTurn===1 && moves.length>=2 && (strategy!=="random" || Math.random()<0.2)){S.players[S.current].joker=false; S.picksLeftThisTurn=2; S.events.jokerDouble[S.current]++;}
 if(strategy==="random") return moves[Math.floor(Math.random()*moves.length)]; let best=moves[0],bestV=-Infinity; for(const idx of moves){const v=evalMove(S,idx,strategy,moves.length); if(v>bestV){bestV=v;best=idx;}} return best;}
function simulateOne(startPlayer,strA,strB){const base=shuffle(makeDeck()); const ancient=shuffle(base.filter(c=>ageOf(c.rank)==="ancient")); const modern=shuffle(base.filter(c=>ageOf(c.rank)==="modern"));
 const S={age:"ancient",nextAgeFirst:1-startPlayer,current:startPlayer,ended:false,decks:{ancient,modern},tableau:buildTableau("ancient",ancient),players:[{cards:[],joker:true},{cards:[],joker:true}],picksLeftThisTurn:1,modernSwapStillAvailable:false,events:{jokerDouble:[0,0],modernSwap:0}};
 let guard=1000; while(!S.ended && guard-->0){const strat=S.current===0?strA:strB; const mv=chooseMove(S,strat); if(mv===null){S.picksLeftThisTurn=1; S.current=1-S.current; continue;} applyTake(S,mv);} const score=scoreFromCards(S.players[0].cards,S.players[1].cards);
 const vpA=score.vp[0], vpB=score.vp[1]; const winner=S.winner!==undefined?(S.winner===0?"a":"b"):(vpA===vpB?"draw":(vpA>vpB?"a":"b")); const winBy=S.winBy || (winner==="draw"?"Pareggio punti":"Punti");
 return {vpA,vpB,margin:vpB-vpA,winner,winBy,score,events:S.events};}
function renderRows(tbody,rows){tbody.innerHTML=rows.map(r=>`<tr><td>${r[0]}</td><td>${r[1]}</td>${r[2]!==undefined?`<td>${r[2]}</td>`:""}</tr>`).join("");}
function renderHistogram(margins){const buckets=new Map(); for(let x=-20;x<=20;x+=4) buckets.set(`${x}..${x+3}`,0); buckets.set("<=-21",0); buckets.set(">=21",0); for(const m of margins){if(m<=-21)buckets.set("<=-21",buckets.get("<=-21")+1); else if(m>=21)buckets.set(">=21",buckets.get(">=21")+1); else {const b=Math.floor((m+20)/4),s=-20+b*4,key=`${s}..${s+3}`; buckets.set(key,buckets.get(key)+1);}} const total=Math.max(1,margins.length),maxN=Math.max(1,...buckets.values()); document.getElementById("marginHist").innerHTML=[...buckets.entries()].map(([k,v])=>`<div class="bar"><div>${k}</div><div class="track"><div class="fill" style="width:${Math.round(100*v/maxN)}%"></div></div><div>${(100*v/total).toFixed(1)}%</div></div>`).join("");}
async function runBatch(){const n=Math.max(1,Math.min(10000,Number(document.getElementById("games").value)||1000)); const sA=document.getElementById("playerStrategy").value, sB=document.getElementById("aiStrategy").value, sm=document.getElementById("startMode").value;
 runBtn.disabled=true; const out=[]; for(let i=0;i<n;i++){const start=sm==="alternate"?(i%2):sm==="a"?0:1; out.push(simulateOne(start,sA,sB)); if((i+1)%20===0||i===n-1){statusEl.textContent=`Simulazione in corso: ${i+1}/${n}`; await new Promise(r=>setTimeout(r,0));}}
 const aWin=out.filter(x=>x.winner==="a").length,bWin=out.filter(x=>x.winner==="b").length,draw=out.length-aWin-bWin;
 document.getElementById("kGames").textContent=String(out.length); document.getElementById("kAWin").textContent=pct(aWin,out.length); document.getElementById("kBWin").textContent=pct(bWin,out.length); document.getElementById("kDraw").textContent=pct(draw,out.length);
 const margins=out.map(x=>x.margin); renderHistogram(margins);
 renderRows(document.getElementById("scoreTable"),[["VP medi",avg(out.map(x=>x.vpA)).toFixed(2),avg(out.map(x=>x.vpB)).toFixed(2)],["VP mediani",out.map(x=>x.vpA).sort((a,b)=>a-b)[Math.floor(out.length/2)],out.map(x=>x.vpB).sort((a,b)=>a-b)[Math.floor(out.length/2)]],["Margine medio (B-A)",avg(margins).toFixed(2),"—"],["Vittorie per Supremazia",pct(out.filter(x=>x.winBy.includes("Supremazia") && x.winner==="a").length,out.length),pct(out.filter(x=>x.winBy.includes("Supremazia") && x.winner==="b").length,out.length)]]);
 renderRows(document.getElementById("eventTable"),[["Supremazia Tecnologica",pct(out.filter(x=>x.winBy.includes("Supremazia Tecnologica")).length,out.length)],["Supremazia Militare",pct(out.filter(x=>x.winBy==="Supremazia Militare").length,out.length)],["Partite ai punti",pct(out.filter(x=>x.winBy==="Punti"||x.winBy==="Pareggio punti").length,out.length)],["Joker doppia presa AI A",avg(out.map(x=>x.events.jokerDouble[0])).toFixed(2)+" / partita"],["Joker doppia presa AI B",avg(out.map(x=>x.events.jokerDouble[1])).toFixed(2)+" / partita"],["Swap ordine Età Moderna",pct(out.filter(x=>x.events.modernSwap>0).length,out.length)]]);
 renderRows(document.getElementById("vpTable"),[["VP Militari (♠)",avg(out.map(x=>x.score.military[0])).toFixed(2),avg(out.map(x=>x.score.military[1])).toFixed(2)],["VP Cultura (♦)",avg(out.map(x=>x.score.culture[0])).toFixed(2),avg(out.map(x=>x.score.culture[1])).toFixed(2)],["VP Tecnologia (♥)",avg(out.map(x=>x.score.techVP[0])).toFixed(2),avg(out.map(x=>x.score.techVP[1])).toFixed(2)],["VP Cibo (♣)",avg(out.map(x=>x.score.food[0])).toFixed(2),avg(out.map(x=>x.score.food[1])).toFixed(2)],["Malus 4 Re",avg(out.map(x=>x.score.kingPenalty[0])).toFixed(2),avg(out.map(x=>x.score.kingPenalty[1])).toFixed(2)],["Swords medi",avg(out.map(x=>x.score.swords[0])).toFixed(2),avg(out.map(x=>x.score.swords[1])).toFixed(2)],["Breakthrough medi",avg(out.map(x=>x.score.breakthrough[0])).toFixed(2),avg(out.map(x=>x.score.breakthrough[1])).toFixed(2)]]);
 statusEl.textContent=`Completato: ${n} partite.`; runBtn.disabled=false;}
runBtn.addEventListener("click",runBatch);
statusEl.textContent="Pronto. Core statistico allineato a jow.html (iframe su jow.html).";
})();
</script>
</body>
</html>
