<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jokers of Wonders</title>
  <style>
    :root{
      --bg:#101522; --panel:#1b2436; --panel2:#232f46; --text:#eef2ff; --muted:#b7c2e6;
      --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444; --accent:#60a5fa;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif; background:radial-gradient(circle at top,#1c2740,#0b1020 60%); color:var(--text); display:flex; flex-direction:column; overflow:hidden}
    header{padding:10px 14px; border-bottom:1px solid #334155; background:#0b1020cc; position:sticky; top:0; z-index:20; backdrop-filter:blur(5px)}
    h1{margin:0;font-size:18px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:space-between}
    button{background:#1f2c45; border:1px solid #4b5d87; color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer}
    button.primary{background:#1d4ed8; border-color:#2563eb}
    button:disabled{opacity:.5;cursor:not-allowed}
    main{max-width:1200px; width:100%; margin:0 auto; padding:12px; display:grid; gap:12px; grid-template-columns:1.3fr .7fr; flex:1; min-height:0}
    @media (max-width: 980px){main{grid-template-columns:1fr}}
    .panel{background:#111a2dcc; border:1px solid #334155; border-radius:14px; overflow:hidden; display:flex; flex-direction:column; min-height:0}
    .hd{padding:10px 12px; border-bottom:1px solid #334155; font-weight:700; display:flex; justify-content:space-between; align-items:center; gap:8px}
    .bd{padding:10px; min-height:0}
    .status{display:grid; gap:8px; grid-template-columns:repeat(2,minmax(0,1fr)); font-size:13px}
    .pill{background:#0f172a; border:1px solid #334155; border-radius:999px; padding:3px 8px; color:var(--muted); font-size:12px}
    .tableauWrap{overflow:hidden; display:flex; justify-content:center; align-items:flex-start}
    .tableau{position:relative; margin:0; transform-origin:top left}
    .sidePanel .bd{overflow:auto}
    .card{position:absolute; width:64px; height:90px; border-radius:12px; border:1px solid rgba(255,255,255,.14); box-shadow:0 10px 18px rgba(0,0,0,.32); display:flex; align-items:center; justify-content:center; font-weight:700; user-select:none; transition:transform .12s; text-align:center}
    .card::after{content:"";position:absolute;inset:0;border-radius:inherit;box-shadow:inset 0 1px 0 rgba(255,255,255,.18);pointer-events:none}
    .card .big{font-size:18px; font-weight:760; line-height:1}
    .card .small{position:absolute; top:5px; left:50%; transform:translateX(-50%); font-size:10px; color:rgba(255,255,255,.78); font-weight:600; letter-spacing:.2px; white-space:nowrap}
    .card .cornerR{position:absolute; top:5px; right:6px; font-size:10px; color:rgba(255,255,255,.78)}
    .faceDown{background:linear-gradient(145deg,#6b7280,#374151); color:#d1d5db; cursor:default}
    .open{cursor:pointer}
    .open:hover{transform:translateY(-2px)}
    .accessible{box-shadow:0 0 0 4px rgba(145,126,185,.95),0 0 0 7px rgba(145,126,185,.45),0 18px 34px rgba(0,0,0,.55)}
    .accessible::before{content:"";position:absolute;inset:0;border-radius:inherit;background:linear-gradient(180deg,rgba(255,255,255,.18),rgba(255,255,255,0) 60%);pointer-events:none;z-index:1}
    .blocked{filter:saturate(.85) brightness(.9); box-shadow:0 6px 12px rgba(0,0,0,.35); transform:translateY(2px) scale(.985); cursor:not-allowed}
    .blocked::after{content:"";position:absolute;inset:0;border-radius:inherit;background:linear-gradient(180deg,rgba(0,0,0,.35),rgba(0,0,0,0) 55%);pointer-events:none;z-index:1}
    .overlapped{box-shadow:0 12px 22px rgba(0,0,0,.48),0 0 0 1px rgba(15,23,42,.95)}
    .covering{box-shadow:0 16px 30px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,.08)}
    .removed{display:none}
    .sS{background:linear-gradient(180deg,#7f1d1d,#450a0a); color:#fee2e2}
    .sH{background:linear-gradient(180deg,#fef08a,#facc15); color:#422006}
    .sD{background:linear-gradient(180deg,#0ea5e9,#0369a1); color:#e0f2fe}
    .sC{background:linear-gradient(180deg,#16a34a,#166534); color:#dcfce7}
    .collections{display:grid; gap:8px}
    .pbox{border:1px solid #334155; border-radius:12px; padding:8px; background:#0f172a}
    .pbox.active{border-color:#60a5fa; box-shadow:0 0 0 2px #60a5fa33 inset}
    .cardsMini{display:flex; flex-wrap:wrap; gap:4px; margin-top:6px}
    .chip{padding:3px 7px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); font-size:11px; color:rgba(255,255,255,.9)}
    .chip.sS{border-color:rgba(239,68,68,.45)}
    .chip.sH{border-color:rgba(250,204,21,.45)}
    .chip.sD{border-color:rgba(56,189,248,.45)}
    .chip.sC{border-color:rgba(34,197,94,.45)}
    .takenGrid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px; margin-top:8px}
    .takenCol{border:1px solid #334155; border-radius:10px; padding:6px; background:#0b1220}
    .takenTitle{font-size:11px; color:var(--muted); margin-bottom:4px}
    .log{height:220px; overflow:auto; background:#0b1220; border:1px solid #334155; border-radius:10px; padding:8px; font-size:12px}
    .line{margin:0 0 5px; color:#dbeafe}
    dialog{border:1px solid #334155; border-radius:12px; padding:14px; background:#0f172a; color:var(--text); width:min(560px,92vw)}
    .optRow{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px}
  </style>
</head>
<body>
<header>
  <div class="row">
    <h1>Jokers of Wonders ‚Äî simulatore completo</h1>
    <div class="row">
      <button class="primary" id="newGameBtn">Nuova partita</button>
      <span class="pill" id="agePill"></span>
      <span class="pill" id="turnPill"></span>
    </div>
  </div>
</header>
<main>
  <section class="panel tableauPanel">
    <div class="hd"><span>Tableau</span><span id="tableauInfo" class="pill"></span></div>
    <div class="bd tableauWrap"><div id="tableau" class="tableau"></div></div>
  </section>
  <section class="panel sidePanel">
    <div class="hd">Giocatori</div>
    <div class="bd">
      <div class="row" style="margin-bottom:8px">
        <button id="useJokerBtn">Usa Joker (2 prese)</button>
      </div>
      <div class="status" id="statusGrid"></div>
      <div class="collections" id="collections"></div>
      <h3>Log</h3>
      <div class="log" id="log"></div>
    </div>
  </section>
</main>

<dialog id="modal"></dialog>

<script>
const SUITS=["S","D","H","C"];
const SUIT_NAME={S:"‚ô† Military",D:"‚ô¶ Culture",H:"‚ô• Technology",C:"‚ô£ Food"};
const SUIT_ICON={S:"‚ô†",D:"‚ô¶",H:"‚ô•",C:"‚ô£"};
const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RANK_VAL=Object.fromEntries(RANKS.map((r,i)=>[r,i+1]));
const TABLEAU_MODEL={
  ancient:[
    {faceDown:false,xs:[2,4]},
    {faceDown:true,xs:[1.5,2.5,3.5,4.5]},
    {faceDown:false,xs:[0,1,2,3,4,5,6]},
    {faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5]},
    {faceDown:false,xs:[1,2,3,4,5]}
  ],
  modern:[
    {faceDown:false,xs:[2,5]},
    {faceDown:true,xs:[1.5,2.5,3.5,4.5,5.5]},
    {faceDown:false,xs:[0,1,2,3,4,5,6,7]},
    {faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5,6.5]},
    {faceDown:false,xs:[1,2,3,4,5,6]}
  ]
};
let G=null;
let aiTimer=null;

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function makeDeck(){
  const cards=[]; let id=0;
  for(const s of SUITS){for(const r of RANKS){cards.push({id:id++,suit:s,rank:r});}}
  return cards;
}
function ageOf(rank){return ["A","2","3","4","5","6"].includes(rank)?"ancient":"modern";}
function label(c){return `${c.rank}${SUIT_ICON[c.suit]}`;}
function cardClass(c){return `s${c.suit}`;}

function layout(model){
  const w=64,h=90;
  const overlap=(110-42)*0.6; // riduce del 40% la sovrapposizione verticale precedente
  const v=h-overlap;
  const hStep=68;
  const allX=model.flatMap(r=>r.xs);
  const minX=Math.min(...allX), maxX=Math.max(...allX);
  const width=w+(maxX-minX)*hStep;
  const pos=[];
  let idx=0;
  for(let row=0;row<model.length;row++){
    for(let col=0;col<model[row].xs.length;col++){
      const gx=model[row].xs[col];
      pos[idx++]={row,col,gridX:gx,x:(gx-minX)*hStep,y:row*v};
    }
  }
  return {w,h,hStep,minX,pos,width,height:(model.length-1)*v+h};
}

function buildRows(model){
  let idx=0;
  return model.map((cfg,row)=>cfg.xs.map((gridX,col)=>({idx:idx++,row,col,gridX})));
}
function buildCovering(rows){
  const total=rows.reduce((a,r)=>a+r.length,0);
  const coveredBy=Array.from({length:total},()=>[]);
  for(let r=0;r<rows.length-1;r++){
    const upper=rows[r], lower=rows[r+1];
    const lowerByX=new Map(lower.map(s=>[s.gridX,s.idx]));
    for(const slot of upper){
      const c1=lowerByX.get(slot.gridX-0.5);
      const c2=lowerByX.get(slot.gridX+0.5);
      if(c1!==undefined) coveredBy[slot.idx].push(c1);
      if(c2!==undefined) coveredBy[slot.idx].push(c2);
    }
  }
  return coveredBy;
}
function buildCoveredBy(covering){
  const coveredBy=Array.from({length:covering.length},()=>[]);
  for(let i=0;i<covering.length;i++) for(const c of covering[i]) coveredBy[c].push(i);
  return coveredBy;
}
function buildTableau(age,deck){
  const model=TABLEAU_MODEL[age], geom=layout(model), slots=[];
  const rows=buildRows(model);
  const covering=buildCovering(rows);
  for(const p of geom.pos){
    const card=deck.pop();
    const faceDown=model[p.row].faceDown;
    slots.push({card,removed:false,faceDown,row:p.row,col:p.col,gridX:p.gridX,x:p.x,y:p.y});
  }
  return {slots,geom,coveredBy:covering,coveredByRev:buildCoveredBy(covering)};
}
function accessibility(tableau){
  const {slots,coveredBy}=tableau;
  return slots.map((s,i)=>{
    if(s.removed) return false;
    return !(coveredBy[i]||[]).some(cIdx=>!slots[cIdx].removed);
  });
}
function flipNew(slots,acc){
  let f=0;
  for(let i=0;i<slots.length;i++) if(!slots[i].removed && slots[i].faceDown && acc[i]){slots[i].faceDown=false; f++;}
  return f;
}
function swords(cards){
  return cards.filter(c=>c.suit==="S").reduce((a,c)=>a+(["A","2","3","4","5"].includes(c.rank)?1:["6","7","8","9","10"].includes(c.rank)?2:3),0);
}
function breakthroughCount(cards){
  const hs=[...new Set(cards.filter(c=>c.suit==="H").map(c=>RANK_VAL[c.rank]))].sort((a,b)=>a-b);
  if(hs.length<2) return 0;
  let links=0;
  for(let i=1;i<hs.length;i++) if(hs[i]===hs[i-1]+1) links++;
  if(hs.includes(1) && hs.includes(13)) links++; // A-K conta come coppia adiacente
  return links;
}
function foodVP(cards){
  const v=cards.filter(c=>c.suit==="C").reduce((a,c)=>a+(c.rank==="A"?1:["J","Q","K"].includes(c.rank)?10:RANK_VAL[c.rank]),0);
  return Math.floor(v/5);
}
function hasCalamityMalus(cards){
  return cards.filter(c=>c.rank==="K").length>=3;
}
function diamondSequences(cards){
  const owned=new Set(cards.filter(c=>c.suit==="D").map(c=>RANK_VAL[c.rank]));
  if(owned.size<2) return [];
  const present=i=>owned.has(i===0?13:i===14?1:i);
  if(owned.size===13) return [{length:13,high:13}];
  const seq=[];
  for(let i=1;i<=13;i++){
    if(!owned.has(i)) continue;
    if(present(i-1)) continue;
    let len=1,cur=i;
    while(present(cur+1)){len++;cur=cur===13?1:cur+1; if(cur===i) break;}
    if(len>=2){
      let high=i;
      for(let k=0,cc=i;k<len;k++){if(cc===13) high=13; else if(high!==13 && cc>high) high=cc; cc=cc===13?1:cc+1;}
      seq.push({length:len,high});
    }
  }
  return seq;
}
function scoreGame(){
  const p0=G.players[0].cards,p1=G.players[1].cards;
  const s0=swords(p0),s1=swords(p1);
  const tech0=breakthroughCount(p0), tech1=breakthroughCount(p1);
  let vp0=0,vp1=0;
  if(s0>s1) vp0+=5; else if(s1>s0) vp1+=5;
  vp0+=foodVP(p0)+tech0*2; vp1+=foodVP(p1)+tech1*2;
  if(hasCalamityMalus(p0)) vp0-=5; if(hasCalamityMalus(p1)) vp1-=5;

  const seqs=[...diamondSequences(p0).map(s=>({...s,owner:0})),...diamondSequences(p1).map(s=>({...s,owner:1}))]
    .sort((a,b)=>b.length-a.length || b.high-a.high);
  const awards=[12,6,3];
  for(let i=0;i<Math.min(awards.length,seqs.length);i++){ if(seqs[i].owner===0) vp0+=awards[i]; else vp1+=awards[i]; }
  return {vp:[vp0,vp1], detail:{s:[s0,s1],tech:[tech0,tech1],seqs}};
}
function checkSupremacy(){
  const [a,b]=G.players.map(p=>p.cards);
  const sw=[swords(a),swords(b)], tp=[breakthroughCount(a),breakthroughCount(b)];
  if(tp[0]>=4) return {winner:0,reason:"Supremazia Tecnologica (4+ Heart pairs)"};
  if(tp[1]>=4) return {winner:1,reason:"Supremazia Tecnologica (4+ Heart pairs)"};
  if(sw[0]-sw[1]>=8) return {winner:0,reason:"Supremazia Militare (>=8 Swords di vantaggio)"};
  if(sw[1]-sw[0]>=8) return {winner:1,reason:"Supremazia Militare (>=8 Swords di vantaggio)"};
  return null;
}

function newGame(){
  const base=shuffle(makeDeck());
  const ancient=shuffle(base.filter(c=>ageOf(c.rank)==="ancient"));
  const modern=shuffle(base.filter(c=>ageOf(c.rank)==="modern"));
  const first=Math.random()<0.5?0:1;
  G={
    age:"ancient", nextAgeFirst:1-first, current:first, ended:false,
    decks:{ancient,modern}, tableau:null,
    players:[{name:"Giocatore 1",cards:[],joker:true,isAI:false},{name:"Giocatore 2 AI (Monte Carlo 3s)",cards:[],joker:true,isAI:true}],
    lastTaken:null, picksLeftThisTurn:1, modernSwapStillAvailable:false, pendingSwapChoice:null
  };
  G.tableau=buildTableau("ancient",G.decks.ancient);
  log(`Nuova partita. Inizia ${G.players[G.current].name}.`);
  render();
}

function log(msg){
  const p=document.createElement("p"); p.className="line"; p.textContent=msg;
  const l=document.getElementById("log"); l.prepend(p);
}

function takeCard(idx){
  if(G.ended) return;
  const slots=G.tableau.slots, accBefore=accessibility(G.tableau);
  const s=slots[idx];
  if(!accBefore[idx]||s.faceDown||s.removed) return;
  s.removed=true;
  const pl=G.players[G.current];
  pl.cards.push(s.card);
  G.lastTaken={player:G.current,card:s.card};

  G.picksLeftThisTurn=Math.max(0,G.picksLeftThisTurn-1);
  const accAfter=accessibility(G.tableau);
  const f=flipNew(slots,accAfter);
  log(`${pl.name} prende ${label(s.card)}.${f?` Rivela ${f} carte.`:""}`);

  const sup=checkSupremacy();
  if(sup){G.ended=true; log(`üèÜ ${G.players[sup.winner].name} vince per ${sup.reason}.`); render(); return;}

  if(G.age==="modern" && G.modernSwapStillAvailable) G.modernSwapStillAvailable=false;
  endTurnOrAge();
}

function canUseJokerDouble(player=G.current){
  return !G.ended && G.current===player && G.players[player].joker && G.picksLeftThisTurn===1 && !G.pendingSwapChoice;
}
function useJokerDouble(player=G.current){
  if(!canUseJokerDouble(player)) return false;
  G.players[player].joker=false;
  G.picksLeftThisTurn=2;
  log(`${G.players[player].name} usa il Joker: 2 prese in questo turno.`);
  return true;
}

function maybeModernSwap(nextFirst){
  const second=1-nextFirst;
  const pl=G.players[second];
  G.modernSwapStillAvailable=true;
  if(!pl.joker) return Promise.resolve(nextFirst);
  if(pl.isAI){
    pl.joker=false;
    log(`${pl.name} usa il Joker per cambiare l'ordine di turno ed √® primo nell'Et√† Moderna.`);
    return Promise.resolve(second);
  }
  return new Promise(resolve=>{
    const d=document.getElementById("modal");
    d.innerHTML=`<h3>Inizio Et√† Moderna</h3><p>${pl.name} sarebbe secondo. Vuole usare il Joker per diventare primo? (scelta ordine turno)</p><div class='optRow'><button id='no'>No</button><button id='yes'>S√¨, usa Joker</button></div>`;
    d.showModal();
    d.querySelector("#no").onclick=()=>{d.close();resolve(nextFirst);};
    d.querySelector("#yes").onclick=()=>{pl.joker=false; d.close(); log(`${pl.name} usa il Joker per cambiare l'ordine di turno ed √® primo nell'Et√† Moderna.`); resolve(second);};
  });
}

function aiSelectMove(){
  const start=performance.now();
  const budget=3000;
  const acc=accessibility(G.tableau);
  const options=[];
  for(let i=0;i<G.tableau.slots.length;i++){
    const s=G.tableau.slots[i];
    if(acc[i]&&!s.removed&&!s.faceDown) options.push(i);
  }
  if(!options.length) return null;
  const stats=new Map(options.map(i=>[i,{n:0,w:0}]));
  let ptr=0;
  while(performance.now()-start<budget){
    const idx=options[ptr++%options.length];
    const res=simulateFromMove(idx);
    const st=stats.get(idx); st.n++; st.w+=res;
  }
  let best=options[0], bestVal=-Infinity;
  for(const [idx,st] of stats.entries()){
    const v=st.w/Math.max(1,st.n);
    if(v>bestVal){bestVal=v;best=idx;}
  }
  return best;
}

function cloneGameState(){
  return {
    age:G.age,
    current:G.current,
    ended:G.ended,
    nextAgeFirst:G.nextAgeFirst,
    picksLeftThisTurn:G.picksLeftThisTurn,
    modernSwapStillAvailable:G.modernSwapStillAvailable,
    players:G.players.map(p=>({cards:p.cards.slice(),joker:p.joker})),
    tableau:{
      slots:G.tableau.slots.map(s=>({...s})),
      coveredBy:G.tableau.coveredBy.map(a=>a.slice())
    },
    decks:{ancient:G.decks.ancient.slice(),modern:G.decks.modern.slice()}
  };
}
function accessibilitySim(T){
  const {slots,coveredBy}=T;
  return slots.map((s,i)=>!s.removed && !(coveredBy[i]||[]).some(c=>!slots[c].removed));
}
function checkSupremacySim(S){
  const sw=S.players.map(p=>swords(p.cards)), tp=S.players.map(p=>breakthroughCount(p.cards));
  if(tp[0]>=4) return 0;
  if(tp[1]>=4) return 1;
  if(sw[0]-sw[1]>=8) return 0;
  if(sw[1]-sw[0]>=8) return 1;
  return null;
}
function flipNewSim(slots,acc){for(let i=0;i<slots.length;i++) if(!slots[i].removed&&slots[i].faceDown&&acc[i]) slots[i].faceDown=false;}
function advanceAgeSim(S){
  if(S.age==="ancient"){
    const second=1-S.nextAgeFirst;
    S.modernSwapStillAvailable=true;
    if(S.players[second].joker) S.players[second].joker=false, S.current=second;
    else S.current=S.nextAgeFirst;
    S.picksLeftThisTurn=1;
    S.age="modern";
    S.tableau=buildTableau("modern",S.decks.modern);
    return;
  }
  S.ended=true;
}
function playRandomTurn(S){
  const acc=accessibilitySim(S.tableau);
  const moves=[];
  for(let i=0;i<S.tableau.slots.length;i++){
    const sl=S.tableau.slots[i]; if(acc[i]&&!sl.removed&&!sl.faceDown) moves.push(i);
  }
  if(!moves.length){S.picksLeftThisTurn=1; S.current=1-S.current; return;}
  if(S.players[S.current].joker && S.picksLeftThisTurn===1 && Math.random()<0.12){
    S.players[S.current].joker=false;
    S.picksLeftThisTurn=2;
  }
  const idx=moves[Math.floor(Math.random()*moves.length)], slot=S.tableau.slots[idx], p=S.players[S.current];
  slot.removed=true; p.cards.push(slot.card);
  S.picksLeftThisTurn=Math.max(0,S.picksLeftThisTurn-1);
  const accAfter=accessibilitySim(S.tableau);
  flipNewSim(S.tableau.slots,accAfter);
  const sup=checkSupremacySim(S); if(sup!==null){S.ended=true; S.winner=sup; return;}
  if(S.age==="modern" && S.modernSwapStillAvailable) S.modernSwapStillAvailable=false;
  if(S.tableau.slots.every(s=>s.removed)) advanceAgeSim(S);
  else if(S.picksLeftThisTurn<=0){S.picksLeftThisTurn=1; S.current=1-S.current;}
}
function simulateFromMove(firstIdx){
  const S=cloneGameState();
  const slot=S.tableau.slots[firstIdx], p=S.players[S.current];
  const acc=accessibilitySim(S.tableau);
  if(!acc[firstIdx]||slot.removed||slot.faceDown) return 0;
  if(S.players[S.current].joker && S.picksLeftThisTurn===1){
    S.players[S.current].joker=false;
    S.picksLeftThisTurn=2;
  }
  slot.removed=true; p.cards.push(slot.card);
  S.picksLeftThisTurn=Math.max(0,S.picksLeftThisTurn-1);
  const accAfter=accessibilitySim(S.tableau);
  flipNewSim(S.tableau.slots,accAfter);
  const sup=checkSupremacySim(S); if(sup!==null) return sup===1?1:0;
  if(S.age==="modern" && S.modernSwapStillAvailable) S.modernSwapStillAvailable=false;
  if(S.tableau.slots.every(s=>s.removed)) advanceAgeSim(S);
  else if(S.picksLeftThisTurn<=0){S.picksLeftThisTurn=1; S.current=1-S.current;}
  let guard=500;
  while(!S.ended && guard-->0) playRandomTurn(S);
  if(S.winner!==undefined) return S.winner===1?1:0;
  const sc0=scoreFor(S,0), sc1=scoreFor(S,1);
  return sc1>=sc0?1:0;
}
function scoreFor(S,i){
  const a=S.players[0].cards,b=S.players[1].cards;
  const sw=[swords(a),swords(b)], tech=[breakthroughCount(a),breakthroughCount(b)];
  let vp=[0,0];
  if(sw[0]>sw[1]) vp[0]+=5; else if(sw[1]>sw[0]) vp[1]+=5;
  vp[0]+=foodVP(a)+tech[0]*2; vp[1]+=foodVP(b)+tech[1]*2;
  if(hasCalamityMalus(a)) vp[0]-=5; if(hasCalamityMalus(b)) vp[1]-=5;
  const seqs=[...diamondSequences(a).map(s=>({...s,o:0})),...diamondSequences(b).map(s=>({...s,o:1}))].sort((x,y)=>y.length-x.length||y.high-x.high);
  [12,6,3].forEach((v,k)=>{if(seqs[k]) vp[seqs[k].o]+=v;});
  return vp[i];
}

function maybeRunAiTurn(){
  if(aiTimer){clearTimeout(aiTimer); aiTimer=null;}
  if(!G||G.ended||G.pendingSwapChoice) return;
  if(!G.players[G.current].isAI) return;
  aiTimer=setTimeout(()=>{
    if(!G||G.ended||G.current!==1) return;
    if(canUseJokerDouble(1)) useJokerDouble(1);
    log("AI Monte Carlo sta pensando (3s)...");
    const idx=aiSelectMove();
    if(idx!==null) takeCard(idx);
  },120);
}

async function endTurnOrAge(){
  const slots=G.tableau.slots;
  if(slots.every(s=>s.removed)){
    if(G.age==="ancient"){
      const start=await maybeModernSwap(G.nextAgeFirst);
      G.age="modern";
      G.tableau=buildTableau("modern",G.decks.modern);
      G.current=start;
      G.picksLeftThisTurn=1;
      log(`Fine Et√† Antica. Inizia Et√† Moderna con ${G.players[G.current].name}.`);
      render(); return;
    }
    G.ended=true;
    const sc=scoreGame();
    const w=sc.vp[0]===sc.vp[1]?null:(sc.vp[0]>sc.vp[1]?0:1);
    log(`Fine partita. VP: ${G.players[0].name} ${sc.vp[0]} - ${G.players[1].name} ${sc.vp[1]}.`);
    log(w===null?"Pareggio." : `üèÜ Vince ${G.players[w].name} ai punti.`);
    render(); return;
  }
  if(G.picksLeftThisTurn<=0){
    G.picksLeftThisTurn=1;
    G.current=1-G.current;
  }
  render();
}

function render(){
  if(!G) return;
  document.getElementById("agePill").textContent=`Et√†: ${G.age==="ancient"?"Antica":"Moderna"}`;
  document.getElementById("turnPill").textContent=G.ended?"Partita conclusa":`Turno: ${G.players[G.current].name}`;
  document.getElementById("tableauInfo").textContent=`Carte rimanenti: ${G.tableau.slots.filter(s=>!s.removed).length}`;

  const sg=document.getElementById("statusGrid");
  const sw=G.players.map(p=>swords(p.cards)), tp=G.players.map(p=>breakthroughCount(p.cards));
  sg.innerHTML=`<div class='pill'>Swords: ${sw[0]} / ${sw[1]}</div><div class='pill'>Breakthroughs: ${tp[0]} / ${tp[1]}</div><div class='pill'>Joker: ${G.players[0].joker?"‚úÖ":"‚ùå"} / ${G.players[1].joker?"‚úÖ":"‚ùå"}</div><div class='pill'>Prese residue turno: ${G.picksLeftThisTurn}</div><div class='pill'>Supremacy militare: diff ${Math.abs(sw[0]-sw[1])}</div>`;

  const useBtn=document.getElementById("useJokerBtn");
  useBtn.disabled=!canUseJokerDouble(0);
  useBtn.onclick=()=>{ if(useJokerDouble(0)) render(); };

  const col=document.getElementById("collections");
  col.innerHTML="";
  for(let i=0;i<2;i++){
    const p=G.players[i];
    const el=document.createElement("div"); el.className=`pbox ${G.current===i&&!G.ended?"active":""}`;
    const bySuit={S:[],H:[],D:[],C:[]};
    p.cards.forEach(c=>bySuit[c.suit].push(c));
    const suitCols=Object.entries(bySuit).map(([s,cards])=>`<div class='takenCol'><div class='takenTitle'>${SUIT_NAME[s]} (${cards.length})</div><div class='cardsMini'>${cards.length?cards.slice(-12).map(c=>`<span class='chip s${c.suit}'>${label(c)}</span>`).join(""):"<span class='chip'>‚Äî</span>"}</div></div>`).join("");
    el.innerHTML=`<strong>${p.name}</strong> (${p.cards.length} carte)<div class='takenGrid'>${suitCols}</div>`;
    col.appendChild(el);
  }

  const t=document.getElementById("tableau"); const wrap=t.parentElement; const panel=t.closest(".tableauPanel"); const headerH=panel?.querySelector(".hd")?.offsetHeight||0;
  const {slots,geom}=G.tableau;
  const wrapStyle=getComputedStyle(wrap);
  const padX=(parseFloat(wrapStyle.paddingLeft)||0)+(parseFloat(wrapStyle.paddingRight)||0);
  const padY=(parseFloat(wrapStyle.paddingTop)||0)+(parseFloat(wrapStyle.paddingBottom)||0);
  const availableW=Math.max(200,wrap.clientWidth-padX);
  const availableH=Math.max(120,window.innerHeight-headerH-36-padY);
  const scale=Math.min(1,availableW/geom.width,availableH/geom.height);
  t.style.width=geom.width+"px";
  t.style.height=geom.height+"px";
  t.style.transform=`scale(${scale})`;
  wrap.style.height=(geom.height*scale)+"px";
  t.innerHTML="";
  const acc=accessibility(G.tableau);
  for(let i=0;i<slots.length;i++){
    const s=slots[i];
    const e=document.createElement("div");
    const hasChildren=(G.tableau.coveredBy[i]||[]).some(c=>!slots[c].removed);
    const hasParent=(G.tableau.coveredByRev?.[i]||[]).some(p=>!slots[p].removed);
    e.className=`card ${s.removed?"removed":""} ${s.faceDown?"faceDown":""} ${!s.faceDown&&!s.removed?cardClass(s.card):""} ${acc[i]&&!s.faceDown&&!s.removed?"open accessible":""} ${!acc[i]&&!s.removed&&!s.faceDown?"blocked":""} ${hasChildren?"covering":""} ${hasParent?"overlapped":""}`;
    e.style.left=s.x+"px"; e.style.top=s.y+"px"; e.style.zIndex=String((s.row+1)*100+s.col);
    e.innerHTML=s.faceDown?"<div class='big'>üÇ†</div>":`<div class='small'>${SUIT_NAME[s.card.suit]}</div><div class='cornerR'>${s.row+1}-${s.col+1}</div><div class='big'>${label(s.card)}</div>`;
    e.onclick=()=>takeCard(i);
    t.appendChild(e);
  }
  maybeRunAiTurn();
}

window.addEventListener("resize",()=>render());

document.getElementById("newGameBtn").onclick=()=>newGame();
document.getElementById("useJokerBtn").onclick=()=>{ if(useJokerDouble(0)) render(); };
newGame();
</script>
</body>
</html>
