<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jokers of Wonders</title>
  <style>
    :root{
      --bg:#101522; --panel:#1b2436; --panel2:#232f46; --text:#eef2ff; --muted:#b7c2e6;
      --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444; --accent:#60a5fa;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif; background:radial-gradient(circle at top,#1c2740,#0b1020 60%); color:var(--text); display:flex; flex-direction:column; overflow:hidden}
    header{border-bottom:1px solid #334155; background:#0b1020cc; position:sticky; top:0; z-index:20; backdrop-filter:blur(5px)}
    .headerRow{display:grid; grid-template-columns:minmax(0,1fr) auto minmax(0,1fr); align-items:center; white-space:nowrap}
    .headerRow h1{grid-column:2; text-align:center}
    .topControls{display:flex; align-items:center; gap:8px; flex-wrap:nowrap; white-space:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch; min-width:0}
    .topControls{grid-column:3; justify-self:end}
    .topControls .pill,.topControls button{flex:0 0 auto}
    header{overflow-x:auto}
    h1{margin:0;font-size:18px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:space-between}
    button{background:#1f2c45; border:1px solid #4b5d87; color:var(--text); padding:2px 10px; border-radius:10px; cursor:pointer}
    button.primary{background:#1d4ed8; border-color:#2563eb}
    button:disabled{opacity:.5;cursor:not-allowed}
    main{max-width:1200px; width:100%; margin:0 auto; padding:12px; display:grid; gap:12px; grid-template-columns:1.3fr .7fr; flex:1; min-height:0}
    @media (max-width: 980px){main{grid-template-columns:1fr}}
    .panel{background:#111a2dcc; border:1px solid #334155; border-radius:14px; overflow:hidden; display:flex; flex-direction:column; min-height:0}
    .hd{padding:10px 12px; border-bottom:1px solid #334155; font-weight:700; display:flex; justify-content:space-between; align-items:center; gap:8px}
    .bd{padding:10px; min-height:0}
    .status{display:grid; gap:8px; grid-template-columns:repeat(2,minmax(0,1fr)); font-size:13px}
    .pill{background:#0f172a; border:1px solid #334155; border-radius:999px; padding:3px 8px; color:var(--muted); font-size:12px}
    .tableauWrap{overflow:hidden; display:flex; justify-content:center; align-items:flex-start}
    .tableau{position:relative; margin:0; transform-origin:top left}
    .sidePanel .bd{overflow:auto}
    .card{position:absolute; width:64px; height:90px; border-radius:14px; background:linear-gradient(180deg,#1f2937,#111827); border:1px solid rgba(255,255,255,.14); box-shadow:0 10px 18px rgba(0,0,0,.32); display:flex; align-items:center; justify-content:center; font-weight:700; user-select:none; transition:transform .10s ease, box-shadow .14s ease, filter .14s ease; text-align:center; will-change:transform}
    .card .big{font-size:22px; font-weight:720; line-height:1; position:relative; z-index:2}
    .card .small{position:absolute; top:6px; left:50%; transform:translateX(-50%); font-size:11px; color:rgba(255,255,255,.96); font-weight:600; letter-spacing:.6px; white-space:nowrap; z-index:3; background:rgba(0,0,0,.22); border:1px solid rgba(255,255,255,.14); border-radius:999px; padding:1px 3px; text-transform:uppercase; text-shadow:0 1px 0 rgba(0,0,0,.35); backdrop-filter:blur(6px)}
    .card .cornerL{position:absolute; top:6px; left:7px; font-size:11px; color:rgba(255,255,255,.78)}
    .card .cornerR{position:absolute; top:6px; right:7px; font-size:11px; color:rgba(255,255,255,.78)}
    .faceDown{background:repeating-linear-gradient(45deg,rgba(255,255,255,.22) 0px,rgba(255,255,255,.22) 6px,transparent 6px,transparent 12px),linear-gradient(180deg,#475569,#1f2937); border-color:rgba(148,163,184,.65); box-shadow:0 8px 16px rgba(0,0,0,.22); color:#d1d5db; cursor:default}
    .open{cursor:pointer}
    @media (hover:hover){
      .open:hover{transform:translateY(-4px) scale(1.02); filter:brightness(1.06) saturate(1.06)}
      .blocked:hover{filter:saturate(.82) brightness(.88)}
    }
    .accessible{box-shadow:0 0 0 4px rgba(145,126,185,.95),0 0 0 7px rgba(145,126,185,.45),0 18px 34px rgba(0,0,0,.55)}
    .accessible{filter:brightness(1.03) saturate(1.05)}
    .accessible::before{content:"";position:absolute;inset:0;border-radius:inherit;background:linear-gradient(180deg,rgba(255,255,255,.18),rgba(255,255,255,0) 60%);pointer-events:none;z-index:1}
    .blocked{filter:saturate(.85) brightness(.9); box-shadow:0 6px 12px rgba(0,0,0,.35); transform:translateY(2px) scale(.985); cursor:not-allowed}
    .blocked::after{content:"";position:absolute;inset:0;border-radius:inherit;background:linear-gradient(180deg,rgba(0,0,0,.35),rgba(0,0,0,0) 55%);pointer-events:none;z-index:1}
    .overlapped{box-shadow:0 12px 22px rgba(0,0,0,.48),0 0 0 1px rgba(15,23,42,.95)}
    .covering{box-shadow:0 16px 30px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,.08)}
    .removed{display:none}
    .suitC{background:linear-gradient(180deg,rgba(34,197,94),rgba(34,197,94)); border-color:rgba(34,197,94)}
    .suitS{background:linear-gradient(180deg,rgba(239,68,68),rgba(239,68,68)); border-color:rgba(239,68,68)}
    .suitD{background:linear-gradient(180deg,rgba(56,189,248),rgba(56,189,248)); border-color:rgba(56,189,248)}
    .suitH{background:linear-gradient(180deg,rgba(250,204,21),rgba(250,204,21)); border-color:rgba(250,204,21)}
    .card .cornerL,.card .cornerR{z-index:4}
    .card.blocked::after,.card.accessible::before{z-index:1}
    .card.faceDown .small,.card.faceDown .big{display:none!important}
    .collections{display:grid; gap:8px}
    .pbox{border:1px solid #334155; border-radius:12px; padding:8px; background:#0f172a}
    .pbox.active{border-color:#60a5fa; box-shadow:0 0 0 2px #60a5fa33 inset}
    .cardsMini{display:flex; flex-wrap:wrap; gap:6px; margin-top:6px}
    .runGroup{display:inline-flex; gap:4px; padding:3px 7px; border-radius:999px; background:rgba(148,163,184,.16); border:1px solid rgba(148,163,184,.35)}
    .runGroup .chip{padding:0; border:0; background:transparent}
    .chip{padding:3px 7px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); font-size:11px; color:rgba(255,255,255,.9)}
    .chip.sS{border-color:rgba(239,68,68,.45)}
    .chip.sH{border-color:rgba(250,204,21,.45)}
    .chip.sD{border-color:rgba(56,189,248,.45)}
    .chip.sC{border-color:rgba(34,197,94,.45)}
    .takenGrid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px; margin-top:8px}
    .takenCol{border:1px solid #334155; border-radius:10px; padding:6px; background:#0b1220}
    .takenTitle{font-size:11px; color:var(--muted); margin-bottom:4px}
    .log{height:220px; overflow:auto; background:#0b1220; border:1px solid #334155; border-radius:10px; padding:8px; font-size:12px}
    .line{margin:0 0 5px; color:#dbeafe}
    dialog{border:1px solid #334155; border-radius:12px; padding:14px; background:#0f172a; color:var(--text); width:min(560px,92vw)}
    .endSummary{width:100%; border-collapse:collapse; margin:10px 0; border:1px solid #334155; border-radius:10px; overflow:hidden; background:#0b1220}
    .endSummary th,.endSummary td{padding:6px 8px; text-align:right; border:1px solid #334155}
    .endSummary th:first-child,.endSummary td:first-child{text-align:left}
    .endSummary tbody td:first-child{color:var(--muted)}
    .endSummary .tot td{font-weight:800; color:#fde68a}
    .winnerBanner{margin-top:10px; padding:12px; border-radius:12px; border:1px solid #2563eb; background:linear-gradient(180deg,#1d4ed8,#1e3a8a); font-weight:900; text-align:center; font-size:19px}
    .winnerBanner.draw{border-color:#64748b; background:linear-gradient(180deg,#334155,#1f2937)}
    .optRow{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px}
  </style>
</head>
<body>
<header>
  <div class="headerRow">
    <h1>Jokers of Wonders</h1><br>
    <div class="topControls">
      <button class="primary" id="newGameBtn">Nuova partita</button>
      <span class="pill" id="agePill"></span>
      <span class="pill" id="turnPill"></span>
    </div>
  </div>
</header>
<main>
  <section class="panel tableauPanel">
    <div class="bd tableauWrap"><div id="tableau" class="tableau"></div></div>
  </section>
  <section class="panel sidePanel">
    <div class="hd">Giocatori</div>
    <div class="bd">
      <div class="row" style="margin-bottom:8px">
        <button id="useJokerBtn">Build Wonder: Extra Turn</button>
      </div>
      <div class="status" id="statusGrid"></div>
      <div class="collections" id="collections"></div>
      <h3>Log</h3>
      <div class="log" id="log"></div>
    </div>
  </section>
</main>

<dialog id="modal"></dialog>

<script>
const SUITS=["S","D","H","C"];
const SUIT_NAME={S:"‚ô† Military",D:"‚ô¶ Culture",H:"‚ô• Technology",C:"‚ô£ Food"};
const SUIT_ICON={S:"‚ô†",D:"‚ô¶",H:"‚ô•",C:"‚ô£"};
const SUIT_ABBR={S:"MILI",D:"CULT",H:"TECH",C:"FOOD"};
const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RANK_VAL=Object.fromEntries(RANKS.map((r,i)=>[r,i+1]));
const MASK13=(1<<13)-1;
const TABLEAU_MODEL={
  ancient:[
    {faceDown:false,xs:[2,4]},
    {faceDown:true,xs:[1.5,2.5,3.5,4.5]},
    {faceDown:false,xs:[0,1,2,3,4,5,6]},
    {faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5]},
    {faceDown:false,xs:[1,2,3,4,5]}
  ],
  modern:[
    {faceDown:false,xs:[2,5]},
    {faceDown:true,xs:[1.5,2.5,3.5,4.5,5.5]},
    {faceDown:false,xs:[0,1,2,3,4,5,6,7]},
    {faceDown:true,xs:[0.5,1.5,2.5,3.5,4.5,5.5,6.5]},
    {faceDown:false,xs:[1,2,3,4,5,6]}
  ]
};
let G=null;
let aiTimer=null;
let renderScheduled=false;

function scheduleRender(){
  if(renderScheduled) return;
  renderScheduled=true;
  requestAnimationFrame(()=>{
    renderScheduled=false;
    render();
  });
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function makeDeck(){
  const cards=[]; let id=0;
  for(const s of SUITS){for(const r of RANKS){cards.push({id:id++,suit:s,rank:r});}}
  return cards;
}
function ageOf(rank){return ["A","2","3","4","5","6"].includes(rank)?"ancient":"modern";}
function label(c){return `${c.rank}${SUIT_ICON[c.suit]}`;}
function cardClass(c){return `suit${c.suit}`;}
function sortCardsByRank(cards){
  return cards.slice().sort((a,b)=>RANK_VAL[a.rank]-RANK_VAL[b.rank]);
}
function groupStraightRuns(cards){
  const sorted=sortCardsByRank(cards);
  if(!sorted.length) return [];
  const groups=[[sorted[0]]];
  for(let i=1;i<sorted.length;i++){
    const prev=groups[groups.length-1][groups[groups.length-1].length-1];
    const cur=sorted[i];
    if(RANK_VAL[cur.rank]===RANK_VAL[prev.rank]+1) groups[groups.length-1].push(cur);
    else groups.push([cur]);
  }
  return groups;
}
function techTripleGroups(cards){
  const cardByRank=new Map(cards.filter(c=>c.suit==="H").map(c=>[RANK_VAL[c.rank],c]));
  let mask=0;
  for(const rk of cardByRank.keys()) mask|=1<<(rk-1);
  mask&=MASK13;
  const triples=[];
  for(let start=1;start<=13;start++){
    const a=start;
    const b=(start%13)+1;
    const c=((start+1)%13)+1;
    const ranks=[a,b,c];
    const tMask=(1<<(a-1))|(1<<(b-1))|(1<<(c-1));
    if((mask&tMask)===tMask) triples.push({tMask,ranks});
  }
  if(!triples.length) return [];
  let bestCount=0;
  let bestMasks=[];
  function dfs(i,used,count,picked){
    if(i>=triples.length){
      if(count>bestCount){bestCount=count; bestMasks=picked.slice();}
      return;
    }
    dfs(i+1,used,count,picked);
    const t=triples[i];
    if((used&t.tMask)===0){
      picked.push(t.tMask);
      dfs(i+1,used|t.tMask,count+1,picked);
      picked.pop();
    }
  }
  dfs(0,0,0,[]);
  const tripleByMask=new Map(triples.map(t=>[t.tMask,t.ranks]));
  return bestMasks
    .map(m=>tripleByMask.get(m) || [])
    .map(ranks=>ranks.map(r=>cardByRank.get(r)).filter(Boolean))
    .filter(g=>g.length===3)
    .sort((a,b)=>RANK_VAL[a[0].rank]-RANK_VAL[b[0].rank]);
}
function diamondMaximalGroups(cards){
  const cardByRank=new Map(cards.filter(c=>c.suit==="D").map(c=>[RANK_VAL[c.rank],c]));
  const owned=new Set(cardByRank.keys());
  if(owned.size<2) return [];
  const present=i=>owned.has(i===0?13:i===14?1:i);
  const groups=[];
  for(let i=1;i<=13;i++){
    if(!owned.has(i)) continue;
    if(present(i-1)) continue;
    const ranks=[i];
    let cur=i;
    while(present(cur+1)){
      cur=cur===13?1:cur+1;
      if(cur===i) break;
      ranks.push(cur);
    }
    if(ranks.length>=2) groups.push(ranks.map(r=>cardByRank.get(r)).filter(Boolean));
  }
  return groups;
}
function groupedSuitTokens(suit,cards){
  const sorted=sortCardsByRank(cards);
  if(suit==="H"){
    const runs=techTripleGroups(sorted);
    const used=new Set(runs.flat().map(c=>c.id));
    const singles=sorted.filter(c=>!used.has(c.id)).map(c=>({key:RANK_VAL[c.rank],cards:[c]}));
    const groups=runs.map(g=>({key:RANK_VAL[g[0].rank],cards:g}));
    return [...singles,...groups].sort((a,b)=>a.key-b.key);
  }
  if(suit==="D"){
    const runs=diamondMaximalGroups(sorted);
    const used=new Set(runs.flat().map(c=>c.id));
    const singles=sorted.filter(c=>!used.has(c.id)).map(c=>({key:RANK_VAL[c.rank],cards:[c]}));
    const groups=runs.map(g=>({key:RANK_VAL[g[0].rank],cards:g}));
    return [...singles,...groups].sort((a,b)=>a.key-b.key);
  }
  return sorted.map(c=>({key:RANK_VAL[c.rank],cards:[c]}));
}

function layout(model){
  const w=64,h=90;
  const overlap=(110-42)*0.6; // riduce del 40% la sovrapposizione verticale precedente
  const v=h-overlap;
  const hStep=68;
  const allX=model.flatMap(r=>r.xs);
  const minX=Math.min(...allX), maxX=Math.max(...allX);
  const width=w+(maxX-minX)*hStep;
  const pos=[];
  let idx=0;
  for(let row=0;row<model.length;row++){
    for(let col=0;col<model[row].xs.length;col++){
      const gx=model[row].xs[col];
      pos[idx++]={row,col,gridX:gx,x:(gx-minX)*hStep,y:row*v};
    }
  }
  return {w,h,hStep,minX,pos,width,height:(model.length-1)*v+h};
}

function buildRows(model){
  let idx=0;
  return model.map((cfg,row)=>cfg.xs.map((gridX,col)=>({idx:idx++,row,col,gridX})));
}
function buildCovering(rows){
  const total=rows.reduce((a,r)=>a+r.length,0);
  const coveredBy=Array.from({length:total},()=>[]);
  for(let r=0;r<rows.length-1;r++){
    const upper=rows[r], lower=rows[r+1];
    const lowerByX=new Map(lower.map(s=>[s.gridX,s.idx]));
    for(const slot of upper){
      const c1=lowerByX.get(slot.gridX-0.5);
      const c2=lowerByX.get(slot.gridX+0.5);
      if(c1!==undefined) coveredBy[slot.idx].push(c1);
      if(c2!==undefined) coveredBy[slot.idx].push(c2);
    }
  }
  return coveredBy;
}
function buildCoveredBy(covering){
  const coveredBy=Array.from({length:covering.length},()=>[]);
  for(let i=0;i<covering.length;i++) for(const c of covering[i]) coveredBy[c].push(i);
  return coveredBy;
}
function buildTableau(age,deck){
  const model=TABLEAU_MODEL[age], geom=layout(model), slots=[];
  const rows=buildRows(model);
  const covering=buildCovering(rows);
  for(const p of geom.pos){
    const card=deck.pop();
    const faceDown=model[p.row].faceDown;
    slots.push({card,removed:false,faceDown,row:p.row,col:p.col,gridX:p.gridX,x:p.x,y:p.y});
  }
  return {slots,geom,coveredBy:covering,coveredByRev:buildCoveredBy(covering)};
}
function accessibility(tableau){
  const {slots,coveredBy}=tableau;
  return slots.map((s,i)=>{
    if(s.removed) return false;
    return !(coveredBy[i]||[]).some(cIdx=>!slots[cIdx].removed);
  });
}
function flipNew(slots,acc){
  let f=0;
  for(let i=0;i<slots.length;i++) if(!slots[i].removed && slots[i].faceDown && acc[i]){slots[i].faceDown=false; f++;}
  return f;
}
function bitOfRank(rank){ return 1<<(RANK_VAL[rank]-1); }
function popcount13(x){ x>>>=0; let c=0; while(x){ x&=x-1; c++; } return c; }
function techSequenceCountFromMask(mask){
  mask&=MASK13;
  const triples=[];
  for(let start=1;start<=13;start++){
    const a=start;
    const b=(start%13)+1;
    const c=((start+1)%13)+1;
    const tMask=(1<<(a-1))|(1<<(b-1))|(1<<(c-1));
    if((mask&tMask)===tMask) triples.push(tMask);
  }
  if(!triples.length) return 0;
  let best=0;
  function dfs(i,used,count){
    if(i>=triples.length){ if(count>best) best=count; return; }
    dfs(i+1,used,count);
    const t=triples[i];
    if((used&t)===0) dfs(i+1,used|t,count+1);
  }
  dfs(0,0,0);
  return best;
}
function diamondAdjFromMask(mask){
  mask&=MASK13;
  const rot=((mask<<1)&MASK13) | (mask>>>12);
  return popcount13(mask&rot);
}
function swordValue(card){
  const v=RANK_VAL[card.rank];
  return (v<=9) ? 1 : 2;
}
function clubValue(card){
  if(card.rank==="A") return 1;
  if(card.rank==="J" || card.rank==="Q" || card.rank==="K") return 10;
  return RANK_VAL[card.rank];
}
function kingRiskFromCount(k){
  if(k>=3) return -3;
  if(k===2) return -0.6;
  return 0;
}
function updateFeat(feat,card){
  if(card.suit==="S") feat.sw+=swordValue(card);
  if(card.suit==="H"){
    feat.hMask|=bitOfRank(card.rank);
    feat.hLinks=techSequenceCountFromMask(feat.hMask);
  }
  if(card.suit==="C") feat.cSum+=clubValue(card);
  if(card.suit==="D"){
    feat.dMask|=bitOfRank(card.rank);
    feat.dAdj=diamondAdjFromMask(feat.dMask);
  }
  if(card.rank==="K") feat.kCount+=1;
}
function swords(cards){
  return cards.filter(c=>c.suit==="S").reduce((a,c)=>a+swordValue(c),0);
}
function breakthroughCount(cards){
  const hMask=cards
    .filter(c=>c.suit==="H")
    .reduce((m,c)=>m|bitOfRank(c.rank),0);
  return techSequenceCountFromMask(hMask);
}
function foodVP(cards){
  const v=cards.filter(c=>c.suit==="C").reduce((a,c)=>a+(c.rank==="A"?1:["J","Q","K"].includes(c.rank)?10:RANK_VAL[c.rank]),0);
  return Math.floor(v/5);
}
function hasCalamityMalus(cards){
  return cards.filter(c=>c.rank==="K").length>=3;
}
function diamondSequences(cards){
  const owned=new Set(cards.filter(c=>c.suit==="D").map(c=>RANK_VAL[c.rank]));
  if(owned.size<2) return [];
  const present=i=>owned.has(i===0?13:i===14?1:i);
  if(owned.size===13) return [{length:13,high:13}];
  const seq=[];
  for(let i=1;i<=13;i++){
    if(!owned.has(i)) continue;
    if(present(i-1)) continue;
    let len=1,cur=i;
    while(present(cur+1)){len++;cur=cur===13?1:cur+1; if(cur===i) break;}
    if(len>=2){
      let high=i;
      for(let k=0,cc=i;k<len;k++){if(cc===13) high=13; else if(high!==13 && cc>high) high=cc; cc=cc===13?1:cc+1;}
      seq.push({length:len,high});
    }
  }
  return seq;
}
function scoreGame(){
  const p0=G.players[0].cards,p1=G.players[1].cards;
  const s0=swords(p0),s1=swords(p1);
  const tech0=breakthroughCount(p0), tech1=breakthroughCount(p1);
  const techVP=[0,0];
  if(tech0>0 && tech1===0) techVP[0]=5;
  else if(tech1>0 && tech0===0) techVP[1]=5;
  const food0=foodVP(p0), food1=foodVP(p1);
  const calam0=hasCalamityMalus(p0), calam1=hasCalamityMalus(p1);
  const military=[0,0];
  if(s0>s1) military[0]=5; else if(s1>s0) military[1]=5;

  const culture=[0,0];
  const seqs=[...diamondSequences(p0).map(s=>({...s,owner:0})),...diamondSequences(p1).map(s=>({...s,owner:1}))]
    .sort((a,b)=>b.length-a.length || b.high-a.high);
  const awards=[10,6,3];
  const cultureAwards=[];
  for(let i=0;i<Math.min(awards.length,seqs.length);i++){
    const award=awards[i];
    culture[seqs[i].owner]+=award;
    cultureAwards.push({owner:seqs[i].owner,vp:award,length:seqs[i].length});
  }

  const vp0=military[0]+food0+techVP[0]+culture[0]-(calam0?5:0);
  const vp1=military[1]+food1+techVP[1]+culture[1]-(calam1?5:0);

  return {
    vp:[vp0,vp1],
    detail:{
      swords:[s0,s1],
      military,
      food:[food0,food1],
      tech:[tech0,tech1],
      techVP,
      culture,
      calamity:[calam0?-5:0,calam1?-5:0],
      cultureAwards
    }
  };
}
function checkSupremacy(){
  const f0=G.players[0].feat, f1=G.players[1].feat;
  if(f0.hLinks>=2) return {winner:0,reason:"Supremazia Tecnologica (>=2 Technological Sequences)"};
  if(f1.hLinks>=2) return {winner:1,reason:"Supremazia Tecnologica (>=2 Technological Sequences)"};
  if(f0.sw - f1.sw >= 7) return {winner:0,reason:"Supremazia Militare (>=7 Swords di vantaggio)"};
  if(f1.sw - f0.sw >= 7) return {winner:1,reason:"Supremazia Militare (>=7 Swords di vantaggio)"};
  return null;
}

function newGame(){
  const base=shuffle(makeDeck());
  const ancient=shuffle(base.filter(c=>ageOf(c.rank)==="ancient"));
  const modern=shuffle(base.filter(c=>ageOf(c.rank)==="modern"));
  const first=Math.random()<0.5?0:1;
  G={
    age:"ancient", nextAgeFirst:1-first, current:first, ended:false,
    decks:{ancient,modern}, tableau:null,
    players:[
      {name:"Giocatore 1",cards:[],joker:true,isAI:false,feat:{sw:0,hMask:0,hLinks:0,cSum:0,dMask:0,dAdj:0,kCount:0}},
      {name:"Giocatore 2",cards:[],joker:true,isAI:true,feat:{sw:0,hMask:0,hLinks:0,cSum:0,dMask:0,dAdj:0,kCount:0}}
    ],
    lastTaken:null, picksLeftThisTurn:1, modernSwapStillAvailable:false, pendingSwapChoice:null
  };
  G.tableau=buildTableau("ancient",G.decks.ancient);
  log(`Nuova partita. Inizia ${G.players[G.current].name}.`);
  render();
}

function log(msg){
  const p=document.createElement("p"); p.className="line"; p.textContent=msg;
  const l=document.getElementById("log"); l.prepend(p);
}

function takeCard(idx){
  if(G.ended) return;
  const slots=G.tableau.slots, accBefore=accessibility(G.tableau);
  const s=slots[idx];
  if(!accBefore[idx]||s.faceDown||s.removed) return;
  s.removed=true;
  const pl=G.players[G.current];
  pl.cards.push(s.card);
  updateFeat(pl.feat,s.card);
  G.lastTaken={player:G.current,card:s.card};

  G.picksLeftThisTurn=Math.max(0,G.picksLeftThisTurn-1);
  const accAfter=accessibility(G.tableau);
  const f=flipNew(slots,accAfter);
  log(`${pl.name} prende ${label(s.card)}.${f?` Rivela ${f} carte.`:""}`);

  const sup=checkSupremacy();
  if(sup){G.ended=true; log(`üèÜ ${G.players[sup.winner].name} vince per ${sup.reason}.`); render(); return;}

  if(G.age==="modern" && G.modernSwapStillAvailable) G.modernSwapStillAvailable=false;
  endTurnOrAge();
}

function canUseJokerDouble(player=G.current){
  return !G.ended && G.current===player && G.players[player].joker && G.picksLeftThisTurn===1 && !G.pendingSwapChoice;
}
function useJokerDouble(player=G.current){
  if(!canUseJokerDouble(player)) return false;
  G.players[player].joker=false;
  G.picksLeftThisTurn=2;
  log(`${G.players[player].name} costruisce Wonder (Extra Turn): 2 prese in questo turno.`);
  return true;
}

function showEndgameModal(sc,winner){
  const d=document.getElementById("modal");
  const p0=G.players[0].name, p1=G.players[1].name;
  const rows=[
    {label:"Militare",a:sc.detail.military[0],b:sc.detail.military[1]},
    {label:"Cibo",a:sc.detail.food[0],b:sc.detail.food[1]},
    {label:"Tecnologia",a:sc.detail.techVP[0],b:sc.detail.techVP[1]},
    {label:"Cultura",a:sc.detail.culture[0],b:sc.detail.culture[1]},
    {label:"Calamit√†",a:sc.detail.calamity[0],b:sc.detail.calamity[1]}
  ];
  const cultureText=sc.detail.cultureAwards.length
    ? sc.detail.cultureAwards.map((x,i)=>`${i+1}¬∞ ${x.vp} VP ‚Üí ${G.players[x.owner].name} (sequenza ${x.length})`).join("<br>")
    : "Nessun bonus Cultura assegnato.";
  d.innerHTML=`
    <h3>Fine partita</h3>
    <p>Riepilogo punti vittoria:</p>
    <table class='endSummary'>
      <thead>
        <tr><th></th><th>P1</th><th>P2</th></tr>
      </thead>
      <tbody>
        ${rows.map(r=>`<tr><td>${r.label}</td><td><strong>${r.a}</strong></td><td><strong>${r.b}</strong></td></tr>`).join("")}
      </tbody>
      <tfoot>
        <tr class='tot'><td>Totale VP</td><td><strong>${sc.vp[0]}</strong></td><td><strong>${sc.vp[1]}</strong></td></tr>
      </tfoot>
    </table>
    <p><strong>${p0}</strong> vs <strong>${p1}</strong></p>
    <p style='color:var(--muted);margin-top:8px'>Bonus Cultura: ${cultureText}</p>
    <div class='winnerBanner ${winner===null?"draw":""}'>${winner===null?"ü§ù Pareggio" : `üèÜ Vince ${G.players[winner].name}`}</div>
    <div class='optRow'><button id='closeEnd'>Chiudi</button></div>
  `;
  d.querySelector("#closeEnd").onclick=()=>d.close();
  d.showModal();
}

function maybeModernSwap(nextFirst){
  const second=1-nextFirst;
  const pl=G.players[second];
  G.modernSwapStillAvailable=true;
  if(!pl.joker) return Promise.resolve(nextFirst);
  if(pl.isAI){
    const noSwapState=cloneGameState();
    noSwapState.age="modern";
    noSwapState.current=nextFirst;
    noSwapState.picksLeftThisTurn=1;
    noSwapState.tableau=buildTableau("modern",noSwapState.decks.modern);
    noSwapState.modernSwapStillAvailable=true;
    const swapState=cloneGameState();
    swapState.players[second].joker=false;
    swapState.age="modern";
    swapState.current=second;
    swapState.picksLeftThisTurn=1;
    swapState.tableau=buildTableau("modern",swapState.decks.modern);
    swapState.modernSwapStillAvailable=true;
    const evNo=estimatePolicyEV(noSwapState,1,120);
    const evSwap=estimatePolicyEV(swapState,1,120);
    if(evSwap>evNo+0.03){
      pl.joker=false;
      log(`${pl.name} costruisce Wonder (Seize Initiative) ed √® primo nell'Et√† Moderna.`);
      return Promise.resolve(second);
    }
    return Promise.resolve(nextFirst);
  }
  return new Promise(resolve=>{
    const d=document.getElementById("modal");
    d.innerHTML=`<h3>Inizio Et√† Moderna</h3><p>${pl.name} sarebbe secondo. Vuole costruire Wonder (Seize Initiative) per diventare primo?</p><div class='optRow'><button id='no'>No</button><button id='yes'>S√¨, costruisci Wonder</button></div>`;
    d.showModal();
    d.querySelector("#no").onclick=()=>{d.close();resolve(nextFirst);};
    d.querySelector("#yes").onclick=()=>{pl.joker=false; d.close(); log(`${pl.name} costruisce Wonder (Seize Initiative) ed √® primo nell'Et√† Moderna.`); resolve(second);};
  });
}

function aiSelectMove(){
  const decision=chooseActionWithOptionalJoker();
  if(!decision) return null;
  if(decision.useJoker) useJokerDouble(1);
  return decision.firstIdx;
}

function ucbSelect(stats,total,c=0.9){
  let bestIdx=null,best=-Infinity;
  for(const [idx,st] of stats.entries()){
    if(st.n===0) return idx;
    const mean=st.w/st.n;
    const ucb=mean+c*Math.sqrt(Math.log(total)/st.n);
    if(ucb>best){best=ucb;bestIdx=idx;}
  }
  return bestIdx;
}

function cloneGameState(){
  return {
    age:G.age,
    current:G.current,
    ended:G.ended,
    nextAgeFirst:G.nextAgeFirst,
    picksLeftThisTurn:G.picksLeftThisTurn,
    modernSwapStillAvailable:G.modernSwapStillAvailable,
    players:G.players.map(p=>({cards:p.cards.slice(),joker:p.joker,name:p.name,isAI:p.isAI,feat:{...p.feat}})),
    tableau:{
      slots:G.tableau.slots.map(s=>({...s})),
      coveredBy:G.tableau.coveredBy,
      coveredByRev:G.tableau.coveredByRev
    },
    decks:{ancient:G.decks.ancient.slice(),modern:G.decks.modern.slice()}
  };
}
function accessibilitySim(T){
  const {slots,coveredBy}=T;
  return slots.map((s,i)=>!s.removed && !(coveredBy[i]||[]).some(c=>!slots[c].removed));
}
function checkSupremacySim(S){
  const f0=S.players[0].feat, f1=S.players[1].feat;
  if(f0.hLinks>=2) return 0;
  if(f1.hLinks>=2) return 1;
  if(f0.sw - f1.sw >= 7) return 0;
  if(f1.sw - f0.sw >= 7) return 1;
  return null;
}
function flipNewSim(slots,acc){for(let i=0;i<slots.length;i++) if(!slots[i].removed&&slots[i].faceDown&&acc[i]) slots[i].faceDown=false;}
function staticTakeValue(S,player,card){
  const f=S.players[player].feat;

  const dSw=(card.suit==="S") ? swordValue(card) : 0;

  let dBt=0;
  if(card.suit==="H"){
    const nm=(f.hMask|bitOfRank(card.rank))&MASK13;
    dBt=techSequenceCountFromMask(nm)-f.hLinks;
  }

  let dFood=0;
  if(card.suit==="C"){
    const before=Math.floor(f.cSum/5);
    const after=Math.floor((f.cSum+clubValue(card))/5);
    dFood=after-before;
  }

  let dDia=0;
  if(card.suit==="D"){
    const nm=(f.dMask|bitOfRank(card.rank))&MASK13;
    dDia=diamondAdjFromMask(nm)-f.dAdj;
  }

  const oldKR=kingRiskFromCount(f.kCount);
  const newKR=kingRiskFromCount(f.kCount + (card.rank==="K" ? 1 : 0));
  const dKing=newKR-oldKR;

  return dSw*1.2 + dBt*1.6 + dFood*1.0 + dDia*0.45 + dKing*1.4;
}
function cheapEvalTake(S,player,idx){
  const slot=S.tableau.slots[idx];
  if(!slot || slot.removed || slot.faceDown) return -Infinity;
  const card=slot.card;
  const me=S.players[player].feat;
  const opp=S.players[1-player].feat;

  const dSw=(card.suit==="S") ? swordValue(card) : 0;

  let dBt=0;
  if(card.suit==="H"){
    const nm=(me.hMask|bitOfRank(card.rank))&MASK13;
    dBt=techSequenceCountFromMask(nm)-me.hLinks;
  }

  let dFood=0;
  if(card.suit==="C"){
    const before=Math.floor(me.cSum/5);
    const after=Math.floor((me.cSum+clubValue(card))/5);
    dFood=after-before;
  }

  let dDia=0;
  if(card.suit==="D"){
    const nm=(me.dMask|bitOfRank(card.rank))&MASK13;
    dDia=diamondAdjFromMask(nm)-me.dAdj;
  }

  const oldKR=kingRiskFromCount(me.kCount);
  const newKR=kingRiskFromCount(me.kCount + (card.rank==="K" ? 1 : 0));
  const dKing=newKR-oldKR;

  const deny=(card.suit==="S" ? 0.2 : 0) + (card.suit==="H" ? 0.15 : 0);
  const pressure=Math.max(0,opp.sw-me.sw-5)*0.05;

  const baseScore=dSw*1.2 + dBt*1.6 + dFood*1.0 + dDia*0.45 + dKing*1.4 + deny + pressure;

  let revealBonus=0;
  const rev=S.tableau.coveredByRev?.[idx] || [];
  for(const upperIdx of rev){
    const upper=S.tableau.slots[upperIdx];
    if(!upper || upper.removed) continue;

    const blockers=S.tableau.coveredBy[upperIdx] || [];
    const becomesAccessible=blockers.every(b=>b===idx || S.tableau.slots[b].removed);
    if(!becomesAccessible) continue;

    const w=upper.faceDown ? 0.35 : 0.18;
    revealBonus += w * staticTakeValue(S,player,upper.card);
  }

  return baseScore + revealBonus;
}
function choosePlayoutMove(S,eps=0.12){
  const moves=[];
  const acc=accessibilitySim(S.tableau);
  for(let i=0;i<S.tableau.slots.length;i++){
    const sl=S.tableau.slots[i]; if(acc[i]&&!sl.removed&&!sl.faceDown) moves.push(i);
  }
  if(!moves.length) return null;
  if(Math.random()<eps) return moves[Math.floor(Math.random()*moves.length)];
  let best=moves[0], bestV=-Infinity;
  for(const idx of moves){
    const v=cheapEvalTake(S,S.current,idx);
    if(v>bestV){bestV=v;best=idx;}
  }
  return best;
}
function shouldUseJokerInPlayout(S){
  if(!(S.players[S.current].joker && S.picksLeftThisTurn===1)) return false;
  const moves=[];
  const acc=accessibilitySim(S.tableau);
  for(let i=0;i<S.tableau.slots.length;i++){
    const sl=S.tableau.slots[i]; if(acc[i]&&!sl.removed&&!sl.faceDown) moves.push(i);
  }
  if(moves.length<2) return false;
  const vals=moves.map(idx=>cheapEvalTake(S,S.current,idx)).sort((a,b)=>b-a);
  return vals[1]>0.6;
}
function chooseModernSwapSim(S,nextFirst,aiPlayer=1){
  const second=1-nextFirst;
  if(!S.players[second].joker) return nextFirst;
  const noSwap=cloneState(S);
  noSwap.age="modern";
  noSwap.current=nextFirst;
  noSwap.picksLeftThisTurn=1;
  noSwap.tableau=buildTableau("modern",noSwap.decks.modern);
  noSwap.modernSwapStillAvailable=true;

  const swap=cloneState(S);
  swap.players[second].joker=false;
  swap.age="modern";
  swap.current=second;
  swap.picksLeftThisTurn=1;
  swap.tableau=buildTableau("modern",swap.decks.modern);
  swap.modernSwapStillAvailable=true;

  const evNo=estimatePolicyEV(noSwap,aiPlayer,16);
  const evSwap=estimatePolicyEV(swap,aiPlayer,16);
  if(evSwap>evNo+0.03){
    S.players[second].joker=false;
    return second;
  }
  return nextFirst;
}
function advanceAgeSim(S){
  if(S.age==="ancient"){
    const start=chooseModernSwapSim(S,S.nextAgeFirst,1);
    S.modernSwapStillAvailable=true;
    S.current=start;
    S.picksLeftThisTurn=1;
    S.age="modern";
    S.tableau=buildTableau("modern",S.decks.modern);
    return;
  }
  S.ended=true;
}
function playRandomTurn(S){
  const moves=legalMovesSim(S);
  if(!moves.length){S.picksLeftThisTurn=1; S.current=1-S.current; return;}
  if(shouldUseJokerInPlayout(S)){
    S.players[S.current].joker=false;
    S.picksLeftThisTurn=2;
  }
  const idx=choosePlayoutMove(S,0.14);
  if(idx===null){S.picksLeftThisTurn=1;S.current=1-S.current;return;}
  applyTakeSim(S,idx);
}
function legalMovesSim(S){
  const acc=accessibilitySim(S.tableau);
  const res=[];
  for(let i=0;i<S.tableau.slots.length;i++){
    const sl=S.tableau.slots[i]; if(acc[i]&&!sl.removed&&!sl.faceDown) res.push(i);
  }
  return res;
}
function applyTakeSim(S,idx){
  const slot=S.tableau.slots[idx], p=S.players[S.current];
  slot.removed=true; p.cards.push(slot.card);
  updateFeat(p.feat,slot.card);
  S.picksLeftThisTurn=Math.max(0,S.picksLeftThisTurn-1);
  const accAfter=accessibilitySim(S.tableau);
  flipNewSim(S.tableau.slots,accAfter);
  const sup=checkSupremacySim(S); if(sup!==null){S.ended=true; S.winner=sup; return;}
  if(S.age==="modern" && S.modernSwapStillAvailable) S.modernSwapStillAvailable=false;
  if(S.tableau.slots.every(s=>s.removed)) advanceAgeSim(S);
  else if(S.picksLeftThisTurn<=0){S.picksLeftThisTurn=1; S.current=1-S.current;}
}
function rewardForState(S,aiPlayer=1){
  if(S.winner!==undefined) return S.winner===aiPlayer?1:0;
  const scAi=scoreFor(S,aiPlayer), scOp=scoreFor(S,1-aiPlayer);
  if(scAi>scOp) return 1;
  if(scAi===scOp) return 0.5;
  return 0;
}
function simulateFromMoveState(baseState,firstIdx,aiPlayer=1){
  const S=cloneState(baseState);
  const slot=S.tableau.slots[firstIdx];
  const acc=accessibilitySim(S.tableau);
  if(!acc[firstIdx]||slot.removed||slot.faceDown) return 0;
  applyTakeSim(S,firstIdx);
  if(S.ended) return rewardForState(S,aiPlayer);
  let guard=500;
  while(!S.ended && guard-->0) playRandomTurn(S);
  return rewardForState(S,aiPlayer);
}
function cloneState(S){
  return {
    age:S.age,current:S.current,ended:S.ended,nextAgeFirst:S.nextAgeFirst,picksLeftThisTurn:S.picksLeftThisTurn,
    modernSwapStillAvailable:S.modernSwapStillAvailable,
    players:S.players.map(p=>({cards:p.cards.slice(),joker:p.joker,name:p.name,isAI:p.isAI,feat:{...p.feat}})),
    tableau:{slots:S.tableau.slots.map(s=>({...s})),coveredBy:S.tableau.coveredBy,coveredByRev:S.tableau.coveredByRev},
    decks:{ancient:S.decks.ancient.slice(),modern:S.decks.modern.slice()},winner:S.winner
  };
}
function estimatePolicyEV(startState,aiPlayer=1,rollouts=64){
  let sum=0;
  for(let i=0;i<rollouts;i++){
    const C=cloneState(startState);
    let guard=600;
    while(!C.ended && guard-->0) playRandomTurn(C);
    sum+=rewardForState(C,aiPlayer);
  }
  return sum/Math.max(1,rollouts);
}
function estimateStateEV(baseState,aiPlayer=1,rollouts=20){
  const options=legalMovesSim(baseState);
  if(!options.length) return rewardForState(baseState,aiPlayer);
  const stats=new Map(options.map(i=>[i,{n:0,w:0}]));
  let total=0;
  for(let i=0;i<rollouts;i++){
    const idx=ucbSelect(stats,++total,0.9);
    const res=simulateFromMoveState(baseState,idx,aiPlayer);
    const st=stats.get(idx); st.n++; st.w+=res;
  }
  let best=0;
  for(const st of stats.values()) best=Math.max(best,st.w/Math.max(1,st.n));
  return best;
}
function selectMoveUcb(baseState,budgetMs=3000,aiPlayer=1){
  const start=performance.now();
  const options=legalMovesSim(baseState);
  if(!options.length) return {idx:null,mean:0};
  const stats=new Map(options.map(i=>[i,{n:0,w:0}]));
  let total=0;
  while(performance.now()-start<budgetMs){
    const idx=ucbSelect(stats,++total,0.9);
    const res=simulateFromMoveState(baseState,idx,aiPlayer);
    const st=stats.get(idx); st.n++; st.w+=res;
  }
  let best=options[0],bestVal=-Infinity;
  for(const [idx,st] of stats.entries()){
    const v=st.w/Math.max(1,st.n);
    if(v>bestVal){bestVal=v;best=idx;}
  }
  return {idx:best,mean:bestVal};
}
function chooseActionWithOptionalJoker(){
  const base=cloneGameState();
  const noJ=selectMoveUcb(base,2200,1);
  const canJ=base.players[base.current].joker && base.picksLeftThisTurn===1;
  if(!canJ || noJ.idx===null) return {useJoker:false,firstIdx:noJ.idx};
  const yesState=cloneState(base);
  yesState.players[yesState.current].joker=false;
  yesState.picksLeftThisTurn=2;
  const yes=selectMoveUcb(yesState,700,1);
  if(yes.idx!==null && yes.mean>noJ.mean+0.02) return {useJoker:true,firstIdx:yes.idx};
  return {useJoker:false,firstIdx:noJ.idx};
}
function scoreFor(S,i){
  const a=S.players[0].cards,b=S.players[1].cards;
  const sw=[swords(a),swords(b)], tech=[breakthroughCount(a),breakthroughCount(b)];
  let vp=[0,0];
  if(sw[0]>sw[1]) vp[0]+=5; else if(sw[1]>sw[0]) vp[1]+=5;
  vp[0]+=foodVP(a); vp[1]+=foodVP(b);
  if(tech[0]>0 && tech[1]===0) vp[0]+=5;
  else if(tech[1]>0 && tech[0]===0) vp[1]+=5;
  if(hasCalamityMalus(a)) vp[0]-=5; if(hasCalamityMalus(b)) vp[1]-=5;
  const seqs=[...diamondSequences(a).map(s=>({...s,o:0})),...diamondSequences(b).map(s=>({...s,o:1}))].sort((x,y)=>y.length-x.length||y.high-x.high);
  [10,6,3].forEach((v,k)=>{if(seqs[k]) vp[seqs[k].o]+=v;});
  return vp[i];
}

function maybeRunAiTurn(){
  if(aiTimer){clearTimeout(aiTimer); aiTimer=null;}
  if(!G||G.ended||G.pendingSwapChoice) return;
  if(!G.players[G.current].isAI) return;
  aiTimer=setTimeout(()=>{
    if(!G||G.ended||G.current!==1) return;
    log("AI Monte Carlo sta pensando (3s)...");
    const idx=aiSelectMove();
    if(idx!==null) takeCard(idx);
  },120);
}

async function endTurnOrAge(){
  const slots=G.tableau.slots;
  if(slots.every(s=>s.removed)){
    if(G.age==="ancient"){
      const start=await maybeModernSwap(G.nextAgeFirst);
      G.age="modern";
      G.tableau=buildTableau("modern",G.decks.modern);
      G.current=start;
      G.picksLeftThisTurn=1;
      log(`Fine Et√† Antica. Inizia Et√† Moderna con ${G.players[G.current].name}.`);
      render(); return;
    }
    G.ended=true;
    const sc=scoreGame();
    const w=sc.vp[0]===sc.vp[1]?null:(sc.vp[0]>sc.vp[1]?0:1);
    log(`Fine partita. VP: ${G.players[0].name} ${sc.vp[0]} - ${G.players[1].name} ${sc.vp[1]}.`);
    log(w===null?"Pareggio." : `üèÜ Vince ${G.players[w].name} ai punti.`);
    showEndgameModal(sc,w);
    render(); return;
  }
  if(G.picksLeftThisTurn<=0){
    G.picksLeftThisTurn=1;
    G.current=1-G.current;
  }
  render();
}

function render(){
  if(!G) return;
  document.getElementById("agePill").textContent=`Et√†: ${G.age==="ancient"?"Antica":"Moderna"}`;
  document.getElementById("turnPill").textContent=G.ended?"Partita conclusa":`Turno: ${G.players[G.current].name}`;

  const sg=document.getElementById("statusGrid");
  const sw=G.players.map(p=>swords(p.cards)), tp=G.players.map(p=>breakthroughCount(p.cards));
  sg.innerHTML=`<div class='pill'>Swords: ${sw[0]} / ${sw[1]}</div><div class='pill'>Tech Sequences: ${tp[0]} / ${tp[1]}</div><div class='pill'>Wonder disponibile: ${G.players[0].joker?"‚úÖ":"‚ùå"} / ${G.players[1].joker?"‚úÖ":"‚ùå"}</div><div class='pill'>Prese residue turno: ${G.picksLeftThisTurn}</div><div class='pill'>Supremacy militare: diff ${Math.abs(sw[0]-sw[1])}</div>`;

  const useBtn=document.getElementById("useJokerBtn");
  useBtn.disabled=!canUseJokerDouble(0);
  useBtn.onclick=()=>{ if(useJokerDouble(0)) render(); };

  const col=document.getElementById("collections");
  col.innerHTML="";
  for(let i=0;i<2;i++){
    const p=G.players[i];
    const el=document.createElement("div"); el.className=`pbox ${G.current===i&&!G.ended?"active":""}`;
    const bySuit={S:[],H:[],D:[],C:[]};
    p.cards.forEach(c=>bySuit[c.suit].push(c));
    const suitCols=Object.entries(bySuit).map(([s,cards])=>{
      const sorted=sortCardsByRank(cards);
      const chips=groupedSuitTokens(s,sorted)
        .map(token=>token.cards.length>1
          ? `<span class='runGroup'>${token.cards.map(c=>`<span class='chip s${c.suit}'>${label(c)}</span>`).join("")}</span>`
          : `<span class='chip s${token.cards[0].suit}'>${label(token.cards[0])}</span>`)
        .join("");
      return `<div class='takenCol'><div class='takenTitle'>${SUIT_NAME[s]} (${cards.length})</div><div class='cardsMini'>${cards.length?chips:"<span class='chip'>‚Äî</span>"}</div></div>`;
    }).join("");
    el.innerHTML=`<strong>${p.name}</strong> (${p.cards.length} carte)<div class='takenGrid'>${suitCols}</div>`;
    col.appendChild(el);
  }

  const t=document.getElementById("tableau"); const wrap=t.parentElement; const panel=t.closest(".tableauPanel"); const headerH=panel?.querySelector(".hd")?.offsetHeight||0;
  const {slots,geom}=G.tableau;
  const wrapStyle=getComputedStyle(wrap);
  const padX=(parseFloat(wrapStyle.paddingLeft)||0)+(parseFloat(wrapStyle.paddingRight)||0);
  const padY=(parseFloat(wrapStyle.paddingTop)||0)+(parseFloat(wrapStyle.paddingBottom)||0);
  const availableW=Math.max(200,wrap.clientWidth-padX);
  const panelH=panel?.clientHeight||window.innerHeight;
  const availableH=Math.max(120,panelH-headerH-padY);
  const scale=Math.min(1,availableW/geom.width,availableH/geom.height);
  t.style.width=geom.width+"px";
  t.style.height=geom.height+"px";
  t.style.transform=`scale(${scale})`;
  t.innerHTML="";
  const acc=accessibility(G.tableau);
  for(let i=0;i<slots.length;i++){
    const s=slots[i];
    const e=document.createElement("div");
    const hasChildren=(G.tableau.coveredBy[i]||[]).some(c=>!slots[c].removed);
    const hasParent=(G.tableau.coveredByRev?.[i]||[]).some(p=>!slots[p].removed);
    e.className=`card ${s.removed?"removed":""} ${s.faceDown?"faceDown":""} ${!s.faceDown&&!s.removed?cardClass(s.card):""} ${acc[i]&&!s.faceDown&&!s.removed?"open accessible":""} ${!acc[i]&&!s.removed&&!s.faceDown?"blocked":""} ${hasChildren?"covering":""} ${hasParent?"overlapped":""}`;
    e.style.left=s.x+"px"; e.style.top=s.y+"px"; e.style.zIndex=String((s.row+1)*100+s.col);
    e.innerHTML=s.faceDown?"<div class='big'>üÇ†</div>":`<div class='small'>${SUIT_ABBR[s.card.suit]||SUIT_NAME[s.card.suit]}</div><div class='cornerL'></div><div class='cornerR'></div><div class='big'>${label(s.card)}</div>`;
    e.onclick=()=>takeCard(i);
    t.appendChild(e);
  }
  maybeRunAiTurn();
}

window.addEventListener("resize",scheduleRender);
window.addEventListener("load",()=>{
  scheduleRender();
  requestAnimationFrame(scheduleRender);
});

const tableauWrapEl=document.querySelector(".tableauWrap");
if(tableauWrapEl && typeof ResizeObserver!=="undefined"){
  const tableauResizeObserver=new ResizeObserver(()=>scheduleRender());
  tableauResizeObserver.observe(tableauWrapEl);
}

if(document.fonts?.ready){
  document.fonts.ready.then(()=>scheduleRender());
}

document.getElementById("newGameBtn").onclick=()=>newGame();
document.getElementById("useJokerBtn").onclick=()=>{ if(useJokerDouble(0)) render(); };
newGame();
</script>
</body>
</html>
