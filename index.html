<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mirus – Human vs AI (Monte Carlo, fair)</title>
  <style>

    :root{
      --bg:#00c3ff52; --panel:#111827; --text:#fff; --muted:#fff;
      --acc:#22c55e; --warn:#f59e0b; --danger:#ef4444; --border:#334155;
      --shadow: 0 10px 25px rgba(0,0,0,.35); --radius:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 20% 0%, #1f2a44 0%, var(--bg) 55%, #050814 100%);
      color:var(--text);
      height:100vh;
      overflow:hidden;
    }
    header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(17,24,39,.9), rgba(17,24,39,.4));
      backdrop-filter: blur(6px);
      position: sticky; top:0; z-index: 10;
    }
    header .row{display:flex; gap:12px; flex-wrap:wrap; justify-content:space-between; align-items:center}
    h1{margin:0; font-size:15px; font-weight:650; letter-spacing:.2px}
    .controls{display:flex; gap:8px; flex-wrap:nowrap; align-items:center; justify-content:flex-end; overflow-x:auto; padding-bottom:2px;}
    button, select, input[type="checkbox"]{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      padding:7px 9px;
      border-radius:10px;
      cursor:pointer;
      outline:none;
    }
    button.primary{background: rgba(34,197,94,.16); border-color: rgba(34,197,94,.35)}
    button.danger{background: rgba(239,68,68,.14); border-color: rgba(239,68,68,.35)}
    button:disabled{opacity:.45; cursor:not-allowed}
    main{padding:10px; max-width: 1180px; margin:0 auto; height: calc(100vh - 78px); overflow:hidden;}
    .grid{display:grid; grid-template-columns: 1.25fr .75fr; gap:12px; height:100%;}
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr} }
    .panel{
      background: rgba(17,24,39,.72);
      display:flex;
      flex-direction:column;
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; justify-content:space-between; align-items:center; gap:10px;}
    .panel .bd{padding:10px; flex:1; overflow:auto}
    .pill{font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.16); color: var(--muted);}
    .pill.ok{border-color: rgba(34,197,94,.35); color: rgba(34,197,94,.95)}
    .pill.warn{border-color: rgba(245,158,11,.35); color: rgba(245,158,11,.95)}
    .status{display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:13px; color: var(--muted);}
    .tableau{position:relative; margin:0 auto; padding:4px 0 2px;}
    .rowCards{display:none;}
    .card{
      border-radius: 14px;
      background: linear-gradient(180deg, #1f2937, #111827);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 18px rgba(0,0,0,.32);
      position:absolute; display:flex; align-items:center; justify-content:center; text-align:center;
      user-select:none;
    }
    .card.clickable{cursor:pointer}
    .card .big{font-size: 22px; font-weight: 720; line-height: 1.0;}
    .card .small{
      position:absolute;
      top:6px;
      bottom:auto;
      left:50%;
      transform: translateX(-50%);
      text-align:center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: .3px;
      color: rgba(255,255,255,.72);
    }
    .card.removed{opacity:.18}
    /* Accessible (selectable) cards: brighter and visually "on top" */
    .card.accessible{
      box-shadow:0 0 0 4px rgba(145, 126, 185, 0.95), 0 0 0 7px rgb(145, 126, 185, 0.45), 0 18px 34px rgba(0,0,0,.55);
      z-index: 4;
    }
    .card.accessible::before{
      content:"";
      position:absolute; inset:0;
      border-radius: inherit;
      background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,0) 60%);
      pointer-events:none;
    }

    /* Blocked (not selectable because covered by other cards): slightly darker and visually "under" */
    .card.blocked{
      filter: saturate(.85) brightness(.90);
      box-shadow: 0 6px 12px rgba(0,0,0,.35);
      transform: translateY(2px) scale(.985);
      z-index: 1;
      cursor: not-allowed;
    }
    .card.blocked::after{
      content:"";
      position:absolute; inset:0;
      border-radius: inherit;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0) 55%);
      pointer-events:none;
    }

    /* Cursor fixes: face-down and removed cards should not look clickable */
    .card.faceDown{cursor: default;}
    .card.removed{cursor: default;}

    /* Face colors by suit/type (harmonized gradients) */
	.card.suitC{ background: linear-gradient(180deg, rgba(34,197,94), rgba(34,197,94)); border-color: rgba(34,197,94); }
	.card.suitS{ background: linear-gradient(180deg, rgba(239,68,68), rgba(239,68,68)); border-color: rgba(239,68,68); }
	.card.suitD{ background: linear-gradient(180deg, rgba(56,189,248), rgba(56,189,248)); border-color: rgba(56,189,248); }
	.card.suitH{ background: linear-gradient(180deg, rgba(250,204,21), rgba(250,204,21)); border-color: rgba(250,204,21); }
    .card.suitC .cornerL,.card.suitC .cornerR,
    .card.suitS .cornerL,.card.suitS .cornerR,
    .card.suitD .cornerL,.card.suitD .cornerR,
    .card.suitH .cornerL,.card.suitH .cornerR{ color: rgba(255,255,255,.82); }

    .card .cornerL{position:absolute; top:6px; left:7px; font-size:11px; color: rgba(255,255,255,.78);}
    .card .cornerR{position:absolute; top:6px; right:7px; font-size:11px; color: rgba(255,255,255,.78);}
    .kv{display:grid; grid-template-columns: 1fr 1fr; gap:8px;}
    .box{border:1px solid rgba(255,255,255,.10); border-radius: 14px; padding: 10px; background: rgba(0,0,0,.14);}
    .box h3{margin:0 0 8px; font-size: 13px; letter-spacing:.2px;}
    .box p{margin:0; font-size: 13px; color: var(--muted); line-height:1.35}
    .cardsList{display:flex; flex-wrap:wrap; gap:6px; margin-top: 10px;}

    .compareWrap{margin-top:4px;}
    .compareTable{width:100%; border-collapse:separate; border-spacing:0 8px; table-layout:fixed;}
    .compareTable th{font-size:12px; color:rgba(255,255,255,.72); text-align:left; padding:0 8px 4px; font-weight:650;}
    .compareTable th:first-child{width:128px;}
    .compareTable td{padding:0 8px; vertical-align:top;}

    .compareRow.suitS td .battleCell{ background: rgba(239,68,68,.08); border-color: rgba(239,68,68,.24); }
    .compareRow.suitC td .battleCell{ background: rgba(34,197,94,.08); border-color: rgba(34,197,94,.24); }
    .compareRow.suitH td .battleCell{ background: rgba(250,204,21,.10); border-color: rgba(250,204,21,.24); }
    .compareRow.suitD td .battleCell{ background: rgba(56,189,248,.10); border-color: rgba(56,189,248,.24); }
    .compareRow.wonders td .battleCell{ background: rgba(148,163,184,.08); border-color: rgba(148,163,184,.24); }

    .catCell{
      font-size:12px;
      font-weight:700;
      color:rgba(255,255,255,.92);
      border-radius:10px;
      padding:8px 9px;
      border-left:4px solid transparent;
      background:rgba(255,255,255,.03);
      letter-spacing:.2px;
      white-space:nowrap;
    }
    .catCell.suitS{ background: rgba(239,68,68,.14); border-left-color: rgba(239,68,68,.9); }
    .catCell.suitC{ background: rgba(34,197,94,.14); border-left-color: rgba(34,197,94,.9); }
    .catCell.suitH{ background: rgba(250,204,21,.14); border-left-color: rgba(250,204,21,.9); }
    .catCell.suitD{ background: rgba(56,189,248,.14); border-left-color: rgba(56,189,248,.9); }
    .catCell.wonders{ background: rgba(148,163,184,.14); border-left-color: rgba(148,163,184,.95); }

    .battleCell{
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      padding:7px 8px;
      min-height:56px;
    }
    .battleHead{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:5px;}
    .battleValue{font-size:15px; font-weight:760; line-height:1; color:rgba(255,255,255,.96);}

    .suitValues{display:flex; gap:5px; flex-wrap:wrap;}

    .chip{padding:4px 7px; border-radius: 999px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); font-size: 12px; color: rgba(255,255,255,.85);}
    .chip.marked{border-color: rgba(250,204,21,.72); box-shadow: 0 0 0 1px rgba(250,204,21,.35) inset; background: rgba(250,204,21,.14); color: rgba(255,248,220,.98);}
    .log{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; white-space: pre-wrap; line-height:1.25;
      max-height: 180px; overflow:auto;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px; padding: 10px;
    }
    .note{font-size:12px; color: var(--muted); line-height:1.35;}
    .hr{height:1px; background: rgba(255,255,255,.08); margin:12px 0}
    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  
    .tableauPanel{
      align-self:start;
    }
    .tableauPanel .bd{
      overflow:hidden;
      display:flex;
      flex-direction:column;
      flex:0 0 auto;
    }
    .tableauPanel .tableau{
      flex:0 0 auto;
      justify-content:center;
    }

  
    @media (max-height: 760px){
      .card .big{font-size:20px;}
      .rowCards{gap:6px;}
      .tableau{gap:5px;}
      .panel .bd{padding:8px;}
      .log{max-height: 150px;}
    }

  
  

/* === Responsive fit patch: keep the entire tableau visible (no page scroll) === */
:root{
  --cardW:72px;
  --cardH:96px;
  --cardRad:14px;
  --rowGap:6px;
  --colGap:8px;
}

/* Make the app fill the dynamic viewport without cutting content on mobile browser UI changes */
html, body{ height:100%; }
body{
  min-height: 100vh;
  height: 100dvh;
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* Let <main> consume the remaining space (no fixed header guesswork) */
main{
  flex: 1 1 auto;
  min-height: 0;
  height: auto;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Keep grid/panels shrinkable within the viewport */
.grid{ height:100%; min-height:0; flex: 1 1 auto; }
.panel{ min-height:0; }
.panel .bd{ min-height:0; }

/* Tableau layout uses CSS vars so JS can shrink cards to fit */
.tableau{ gap: var(--rowGap); width:100%; }
.rowCards{ gap: var(--colGap); }

/* Card sizing via CSS vars (JS updates them) */
.card{
  width: var(--cardW);
  height: var(--cardH);
  border-radius: var(--cardRad);
  padding: clamp(4px, calc(var(--cardW) * 0.085), 6px);
}
.card .big{ font-size: clamp(16px, calc(var(--cardW) * 0.305), 22px); }
.card .small{ font-size: clamp(9px, calc(var(--cardW) * 0.150), 11px); top: clamp(4px, calc(var(--cardW) * 0.083), 6px); }
.card .cornerL, .card .cornerR{
  font-size: clamp(9px, calc(var(--cardW) * 0.150), 11px);
  top: clamp(4px, calc(var(--cardW) * 0.083), 6px);
}
.card .cornerL{ left: clamp(5px, calc(var(--cardW) * 0.095), 7px); }
.card .cornerR{ right: clamp(5px, calc(var(--cardW) * 0.095), 7px); }

/* The tableau panel should never scroll; the tableau must fit instead */
.tableauPanel .bd{ overflow:hidden; }

/* On narrow screens, reserve a controlled height for the side panel so the tableau always has room */
@media (max-width: 980px){
  .grid{
    grid-template-columns: 1fr;
    grid-template-rows: minmax(0, 1fr) auto;
  }
  .grid > .tableauPanel{ min-height: 0; }
  .grid > aside.panel{
    height: 26vh;
    min-height: 140px;
    max-height: 230px;
  }
  .tableauPanel details{ display:none; }
}

/* On short screens, hide non-essential notes to preserve tableau height */
@media (max-height: 720px){
  .tableauPanel details{ display:none; }
  header{ padding:8px 10px; }
  .panel .hd{ padding:10px 12px; }
  .panel .bd{ padding:8px; }
  .log{ max-height: 140px; }
}


/* === UI/UX polish patch (styling only; game logic unchanged) === */
:root{
  --focus: rgba(56,189,248,.95);
  --ring: 0 0 0 3px rgba(56,189,248,.30);
  --shadowHard: 0 18px 44px rgba(0,0,0,.45);
  --glass: rgba(255,255,255,.06);
  --glass2: rgba(255,255,255,.10);
}

/* Slightly clearer typography + spacing */
body{ -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility; }
h1{ font-size: 15.5px; }
header{ padding: 10px 12px; }

/* Controls: better touch targets, hover/active, focus ring */
.controls{ gap: 10px; }
button, select{
  min-height: 34px;
  padding: 8px 10px;
  border-radius: 12px;
  transition: transform .08s ease, background .14s ease, border-color .14s ease, box-shadow .14s ease, filter .14s ease;
}
select{
  appearance:none;
  padding-right: 30px;
  background-image:
    linear-gradient(45deg, transparent 50%, rgba(229,231,235,.75) 50%),
    linear-gradient(135deg, rgba(229,231,235,.75) 50%, transparent 50%);
  background-position:
    calc(100% - 16px) 50%,
    calc(100% - 11px) 50%;
  background-size: 6px 6px, 6px 6px;
  background-repeat: no-repeat;
}
button:hover:not(:disabled), select:hover:not(:disabled){
  background: rgba(255,255,255,.085);
  border-color: rgba(255,255,255,.20);
  box-shadow: 0 10px 24px rgba(0,0,0,.18);
}
button:active:not(:disabled){ transform: translateY(1px); }
button.primary:hover:not(:disabled){
  background: rgba(34,197,94,.22);
  border-color: rgba(34,197,94,.48);
}
button.danger:hover:not(:disabled){
  background: rgba(239,68,68,.20);
  border-color: rgba(239,68,68,.48);
}
button:focus-visible, select:focus-visible, summary:focus-visible{
  outline:none;
  box-shadow: var(--ring);
  border-color: rgba(56,189,248,.45);
}
input[type="checkbox"]{
  width: 16px; height: 16px;
  accent-color: rgba(34,197,94,.95);
}

/* Panels: a bit more "glass", clearer separation */
.panel{
  background: linear-gradient(180deg, rgba(17,24,39,.78), rgba(17,24,39,.58));
  border-color: rgba(255,255,255,.12);
  box-shadow: var(--shadowSoft);
}
.panel .hd{
  background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,0));
}
.panel .bd{ scrollbar-gutter: stable both-edges; }

/* PIlls and chips */
.pill{
  background: rgba(255,255,255,.04);
  border-color: rgba(255,255,255,.18);
}
.pill.turn-ai{
  animation: turnAiBlink .9s step-end infinite;
}

@keyframes turnAiBlink{
  50%{ opacity:.35; }
}
.chip{
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  border-color: rgba(255,255,255,.14);
}

/* Cards: micro-interactions + clearer indicators */
.card{
  transition: transform .10s ease, box-shadow .14s ease, filter .14s ease;
  will-change: transform;
}
@media (hover:hover){
  .card.accessible:hover{
    transform: translateY(-4px) scale(1.02);
    filter: brightness(1.06) saturate(1.06);
  }
  .card.blocked:hover{
    filter: saturate(.82) brightness(.88);
  }
}
.card.accessible{ filter: brightness(1.03) saturate(1.05); }
.card.faceDown{
  background:
    repeating-linear-gradient(
      45deg,
      rgba(255,255,255,.22) 0px,
      rgba(255,255,255,.22) 6px,
      transparent 6px,
      transparent 12px
    ),
    linear-gradient(180deg, #475569, #1f2937);
  border-color: rgba(148,163,184,.65);
  box-shadow: 0 8px 16px rgba(0,0,0,.22);
}
.card.removed{ filter: grayscale(.2) brightness(.9); }

/* Corner badges: hide when empty + render as small "badges" */
.card .cornerL:empty, .card .cornerR:empty{ display:none; }
.card .cornerL, .card .cornerR{
  display:flex; align-items:center; justify-content:center;
  min-width: 18px; height: 18px;
  padding: 0 6px;
  border-radius: 999px;
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.12);
  backdrop-filter: blur(6px);
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
}
.card .cornerL{ justify-content:flex-start; }
.card.accessible .cornerR{
  background: rgba(34,197,94,.16);
  border-color: rgba(34,197,94,.42);
  color: rgba(34,197,94,.98);
}
.card.blocked .cornerR{
  background: rgba(0,0,0,.26);
  border-color: rgba(255,255,255,.10);
  color: rgba(229,231,235,.80);
}

/* Log: slightly clearer + nicer scrollbars (where supported) */
.log{
  line-height: 1.32;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
}
.log::-webkit-scrollbar{ width: 10px; }
.log::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.14);
  border: 2px solid rgba(0,0,0,0);
  background-clip: padding-box;
  border-radius: 999px;
}
.log::-webkit-scrollbar-track{ background: rgba(0,0,0,.12); border-radius: 999px; }

/* Modal: cleaner glass + subtle entrance */
#modalOverlay > div{ animation: _modalIn .16s ease-out; }
@keyframes _modalIn{
  from{ transform: translateY(8px) scale(.985); opacity:.2; }
  to{ transform: translateY(0) scale(1); opacity:1; }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  *{ transition:none !important; animation:none !important; scroll-behavior:auto !important; }
}


/* =========================
   UX fit: keep tableau + taken cards fully visible (no page scrolling)
   ========================= */

/* Make taken cards denser and responsive to short viewports */
.suitLabel{ min-width: 74px; }
.chip{
  font-size: clamp(9px, 1.35vh, 12px);
  padding: clamp(2px, .45vh, 4px) clamp(4px, .9vh, 7px);
  border-radius: 999px;
}
.suitRows{ gap: 7px; }
.suitRow{ gap: 7px; }

/* Optional tableau structure note: hide on small screens to preserve height */
@media (max-width: 980px){
  details.tableauDetails{ display:none; }
}

/* On narrow screens, allocate enough space for taken cards while keeping tableau auto-fit */
@media (max-width: 980px){
  .grid{
    grid-template-columns: 1fr;
    grid-template-rows: auto auto;
    gap: 6px;
  }
  .grid > .tableauPanel{ min-height: 0; }
  .grid > aside.panel{
    height: clamp(190px, 34dvh, 340px);
    min-height: 190px;
    max-height: 360px;
  }

  /* Compact side panel spacing */
  .panel .bd{ padding: 10px; }
  .kv{ gap: 8px; }
  .box{ padding: 9px; border-radius: 14px; }
  .box h3{ margin-bottom: 6px; font-size: 12px; }

  /* Summaries are helpful but can steal vertical space on mobile */
  #humanSummary, #aiSummary{ display:none; }

  /* Keep the log available but small; it can scroll internally */
  .log{ max-height: 86px; }
  .logNote{ display:none; }
}

/* Very short screens: further tighten the side panel */
@media (max-width: 980px) and (max-height: 700px){
  .grid > aside.panel{ height: clamp(170px, 30dvh, 300px); min-height: 170px; }
  .suitRows{ gap: 6px; }
  .suitRow{ gap: 6px; }
  .suitLabel{ min-width: 64px; font-size: 11px; }
  .log{ max-height: 72px; }
}


/* Ghost button (subtle) */
button.ghost{
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.12);
  color: rgba(229,231,235,.92);
  padding: 6px 8px;
  border-radius: 10px;
}

/* Log as an overlay drawer on mobile: keep the playfield uncluttered */
#logOpenBtn{ display:none; }
#logCloseBtn{ display:none; }

@media (max-width: 980px){
  #logOpenBtn{ display:inline-flex; }
  .logInline{ display:none; }         /* hide inline log separator */
  #logBox{ display:none; }            /* log does not consume layout height on mobile */
  body.logOpen #logBackdrop{ display:block !important; }
  body.logOpen #logBox{
    display:block !important;
    position:fixed;
    left:50%;
    top:50%;
    transform: translate(-50%,-50%);
    width: min(720px, calc(100% - 28px));
    max-height: calc(100dvh - 28px);
    z-index: 66;
    background: rgba(17,24,39,.97);
    border:1px solid rgba(255,255,255,.14);
    box-shadow: 0 22px 60px rgba(0,0,0,.60);
  }
  body.logOpen #logCloseBtn{ display:inline-flex; }
  body.logOpen #logBox .log{ max-height: calc(100dvh - 220px); }
}

@media (min-width: 981px){
  #logOpenBtn{ display:none; }
  #logCloseBtn{ display:none; }
}

.logHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom: 8px;
}


    .suitMeta{font-size:12px; color: rgba(255,255,255,.86); line-height:1;}
    .suitSep{color: rgba(255,255,255,.25); margin: 0 4px;}
    .suitValues{display:flex; flex-wrap:wrap; gap:6px; align-items:center;}
    .chip.vp{border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); color: rgba(34,197,94,.92);}
    .chip.marked{border-color: rgba(251,191,36,.72); background: rgba(251,191,36,.20); color: rgba(255,248,220,.98); box-shadow: inset 0 0 0 1px rgba(251,191,36,.26); font-weight:700;}
    .vpBadge{color: rgba(34,197,94,.92);}


/* === Card-face label visibility patch ===
   Ensure the suit label (MILI/TECH/FOOD/CULT) is always readable,
   including on "blocked" cards that have a dark overlay pseudo-element.
*/
.card .big{ position:relative; z-index: 2; }
.card .small{
  z-index: 3;
  color: rgba(255,255,255,.96);
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.14);
  border-radius: 999px;
  padding: 1px 3px;
  text-transform: uppercase;
  letter-spacing: .6px;
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
  backdrop-filter: blur(6px);
}
/* Non mostrare mai i corner text sul dorso */
.card.faceDown .small,
.card.faceDown .big{
  display: none !important;
}
.card .cornerL, .card .cornerR{ z-index: 4; }
.card.blocked::after{ z-index: 1; }
.card.accessible::before{ z-index: 1; }

/* === In-game viewport: hide the top header while playing (more space for tableau + taken cards) === */
body.playing header{ display:none; }

/* Show an in-game Leader button inside the side panel header (header is hidden while playing) */
#wonderBtnSide{ display:none; }
body.playing #wonderBtnSide{ display:inline-flex; }


/* === King Wonder overlay (Mirus 2.0) === */
#kingOverlay{display:none; position:fixed; inset:0; background: rgba(0,0,0,.62); z-index: 998; align-items:center; justify-content:center; padding: clamp(8px, 2.4vh, 12px); --kingMiniW:58px; --kingMiniH:80px; --kingGap:6px;}
#kingOverlay .panelBox{ max-width: 760px; width:100%; max-height: calc(100dvh - (clamp(8px, 2.4vh, 12px) * 2)); overflow:hidden; background: rgba(17,24,39,.86); border:1px solid rgba(255,255,255,.16); border-radius: 16px; box-shadow: 0 22px 60px rgba(0,0,0,.65); padding: 10px; display:flex; flex-direction:column; }
#kingOverlay #kingCardsGrid{ flex:1; min-height:0; overflow:auto; padding-right:2px; }
#kingOverlay .miniGrid{ display:flex; flex-wrap:wrap; gap:var(--kingGap); justify-content:center; margin-top:8px; align-content:flex-start; }
#kingOverlay .kingSuitGroup{margin-top:8px;}
#kingOverlay .kingSuitTitle{font-size:12px; color: rgba(229,231,235,.78); margin-bottom:6px;}
#kingOverlay .kingSuitCards{display:flex; flex-wrap:wrap; gap:var(--kingGap);}
#kingOverlay .kingHint{ color: rgba(229,231,235,.92); font-size: 12px; line-height: 1.3; margin-top:4px; }
#kingOverlay .kingReq{ color: rgba(229,231,235,.86); font-size: 11px; margin-top:4px; }
#kingOverlay .kingErr{ color: rgba(239,68,68,.95); font-size: 11px; margin-top:6px; min-height: 14px;}
.miniCard{ width: var(--kingMiniW); height: var(--kingMiniH); border-radius: 12px; border:1px solid rgba(255,255,255,.14); box-shadow: 0 10px 18px rgba(0,0,0,.32); display:flex; align-items:center; justify-content:center; position:relative; user-select:none; cursor:pointer; background: linear-gradient(180deg, #1f2937, #111827); }
.miniCard .big{ font-size: clamp(14px, calc(var(--kingMiniW) * 0.31), 20px); font-weight: 720; line-height: 1.0; }
.miniCard .small{ position:absolute; top:4px; left:50%; transform: translateX(-50%); font-size: clamp(8px, calc(var(--kingMiniW) * 0.14), 10px); font-weight: 650; letter-spacing:.4px; color: rgba(255,255,255,.92); background: rgba(0,0,0,.22); border:1px solid rgba(255,255,255,.14); border-radius: 999px; padding: 1px 3px; text-transform: uppercase; }
.miniCard.finalChoice{ width: calc(var(--kingMiniW) * 0.88); height: calc(var(--kingMiniH) * 0.88); }
.miniCard.finalChoice .big{ font-size: clamp(13px, calc(var(--kingMiniW) * 0.29), 18px); }
.miniCard.finalChoice .small{ font-size: clamp(7px, calc(var(--kingMiniW) * 0.13), 9px); }
.kingActions{display:flex; gap:10px; justify-content:flex-end; margin-top:auto; padding-top:8px;}
.miniCard.selected{ box-shadow:0 0 0 4px rgba(145, 126, 185, 0.95), 0 0 0 7px rgb(145, 126, 185, 0.45), 0 18px 34px rgba(0,0,0,.55); }
.miniCard.disabled{ opacity:.35; cursor:not-allowed; filter: grayscale(.15) brightness(.92); }
.miniCard.suitC{ background: linear-gradient(180deg, rgba(34,197,94,.95), rgba(34,197,94,.55)); border-color: rgba(34,197,94,.90); }
.miniCard.suitS{ background: linear-gradient(180deg, rgba(239,68,68,.95), rgba(239,68,68,.55)); border-color: rgba(239,68,68,.90); }
.miniCard.suitD{ background: linear-gradient(180deg, rgba(56,189,248,.95), rgba(56,189,248,.55)); border-color: rgba(56,189,248,.90); }
.miniCard.suitH{ background: linear-gradient(180deg, rgba(250,204,21,.95), rgba(250,204,21,.55)); border-color: rgba(250,204,21,.90); }




/* =========================================================
   Mobile single-screen layout (no vertical scroll, no horizontal swipe)
   - CSS/HTML only: JS unchanged
   - Goal: tableau + Human/AI values fully visible in one viewport on compact Android
   ========================================================= */

@media (max-width: 980px){
  :root{ --asideH: clamp(260px, 52dvh, 460px); }

  main{ padding: 8px; }

  .grid{
    grid-template-columns: 1fr;
    grid-template-rows: minmax(0, 1fr) minmax(0, var(--asideH));
    gap: 8px;
  }

  /* No internal scrolling on mobile panels */
  .panel .bd{ overflow: hidden; padding: 6px; }

  /* Side panel: fill its grid track (no fixed pixel clamp that forces scrollbars) */
  .grid > aside.panel{ height: 100%; min-height: 0; max-height: none; }

  /* Tighten headers to reclaim vertical space */
  .panel .hd{ padding: 8px 10px; }
  .pill{ font-size: 11px; padding: 3px 7px; }

  /* Compact the Human/AI boxes */
  .kv{ gap: 6px; }
  .box{ padding: 6px; border-radius: 12px; }
  .box h3{ margin: 0 0 4px; font-size: 11px; }
  .cardsList{ margin-top: 6px; gap: 4px; }

  .suitRows{ gap: 4px; margin-top: 6px; }

  /* Make each suit row stable (no row-level wrapping that causes overflow or swipe) */
  .suitRow{
    display: grid;
    grid-template-columns: max-content max-content max-content 1fr;
    column-gap: 4px;
    row-gap: 2px;
    align-items: center;
  }
  .suitLabel{ min-width: 0; font-size: 10px; white-space: nowrap; }
  .suitMeta{ font-size: 10px; }
  .suitSep{ margin: 0 2px; font-size: 10px; }

  /* Values always occupy the flexible last column */
  .suitValues{
    grid-column: 4;
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    align-items: center;
    min-width: 0;
  }

  /* Chips become dense "tokens" (less padding/border => fewer wraps => less height) */
  .chip{
    font-size: 10px;
    padding: 0 3px;
    line-height: 16px;
    border-radius: 8px;
    max-width: 100%;
    overflow-wrap: anywhere;
  }

  /* Reclaim a bit inside the tableau panel too */
  .tableauPanel .bd{ padding: 6px; }
  .tableau{ padding: 2px 0 0; }
}

@media (max-width: 980px) and (max-height: 740px){
  .panel .hd{ padding: 7px 9px; }
  .panel .bd{ padding: 5px; }
  .pill{ font-size: 10px; padding: 2px 6px; }

  .box{ padding: 5px; }
  .box h3{ font-size: 10px; margin-bottom: 3px; }

  .suitLabel, .suitMeta, .suitSep{ font-size: 9px; }
  .chip{ font-size: 9px; line-height: 15px; padding: 0 2px; max-width: 100%; overflow-wrap: anywhere; }
}

@media (max-width: 700px), (max-height: 740px){
  #kingOverlay{ --kingMiniW:52px; --kingMiniH:72px; --kingGap:5px; }
  #kingOverlay .panelBox{ padding: 8px; }
  #kingOverlay .miniGrid{ margin-top: 6px; }
  #kingOverlay .kingSuitGroup{ margin-top: 8px; }
  #kingOverlay .kingHint{ font-size: 11px; }
  #kingOverlay .kingReq, #kingOverlay .kingErr{ font-size: 10px; }
}

@media (max-height: 640px){
  #kingOverlay{ --kingMiniW:46px; --kingMiniH:64px; --kingGap:4px; }
  #kingOverlay .panelBox{ padding: 7px; }
  #kingOverlay .kingHint{ font-size: 10px; margin-top: 3px; }
  #kingOverlay .kingReq{ margin-top: 2px; }
  #kingOverlay .kingErr{ margin-top: 4px; min-height: 12px; }
  .kingActions{ padding-top: 6px; }
}


/* === Mobile fit tweak: keep tableau minimal + compact compare box === */
@media (max-width: 980px){
  .grid{
    grid-template-rows: minmax(0, 1fr) auto;
    align-content: stretch;
  }
  .tableauPanel .hd{ padding: 6px 8px; }
  .tableauPanel .bd{ padding: 4px 6px; }

  .compareWrap{
    margin-top: 0;
    padding: 5px;
    border-radius: 10px;
  }
  .compareTable{ border-spacing: 0 4px; }
  .compareTable th{ font-size: 10px; padding: 0 4px 2px; }
  .compareTable th:first-child{ width: 92px; }
  .compareTable td{ padding: 0 4px; }
  .catCell{ font-size: 10px; padding: 5px 6px; border-left-width: 3px; }
  .battleCell{ min-height: 40px; padding: 5px 6px; }
  .battleHead{ margin-bottom: 3px; }
  .battleValue{ font-size: 13px; }
  .suitValues{ gap: 3px; }
}

/* === Mobile layout: prioritize tableau height so cards can scale up === */
@media (max-width: 980px){
  .grid{
    grid-template-rows: minmax(0, 1fr) auto !important;
    height: 100%;
    min-height: 0;
    align-content: stretch;
  }
  .grid > .tableauPanel{
    min-height: 0;
    align-self: start;
  }
  .grid > aside.panel{
    height: clamp(170px, 30dvh, 280px) !important;
    min-height: 170px;
    max-height: 280px !important;
    align-self: end;
    overflow: hidden;
  }
  .tableauPanel .bd,
  .tableauPanel .tableau{
    flex: 0 0 auto;
    min-height: 0;
  }
}



/* === Layout update: stack playfield and taken-cards panels vertically === */
.grid{
  display:flex !important;
  flex-direction:column;
  gap:12px;
  height:100%;
  min-height:0;
}
.grid > .tableauPanel{
  min-height:0;
  max-height:40vh;
  width:90vw;
}
.grid > aside.panel{
  flex:0 0 auto;
  max-height:57vh;
  min-height:220px;
  width:90vw;	
}
.grid > aside.panel .bd{
  overflow:auto;
}

@media (max-width: 980px){
  main{ padding:8px; }
  .grid{ gap:8px; }
  .grid > .tableauPanel{ flex:1 1 auto; }
  .grid > aside.panel{
    min-height:180px;
    max-height:34dvh;
  }
  .compareTable th:first-child{ width:96px; }
  .battleCell{ min-height:42px; }
}

@media (max-width: 640px){
  .panel .hd{ padding:8px 10px; }
  .panel .bd{ padding:8px; }
  .grid > aside.panel{
    min-height:160px;
    max-height:38dvh;
  }
}

</style>
</head>
<body>
<header>
  <div class="row">
    <div>
      <h1>Mirus – Human vs AI (Monte Carlo “fair”)</h1>
      <div class="status" id="statusLine"></div>
    </div>
    <div class="controls">
      <label style="display:flex; gap:6px; align-items:center; font-size:12px; color: var(--muted);">
        AI
        <select id="aiLevel">
          <option value="random">Random</option>
          <option value="greedy">Greedy</option>
          <option value="mc" selected>MonteCarlo</option>
        </select>
      </label>
      <label style="display:flex; gap:6px; align-items:center; font-size:12px; color: var(--muted);">
        Start
        <select id="whoStarts">
          <option value="human" selected>Human</option>
          <option value="ai">AI</option>
        </select>
      </label>
      <label style="display:flex; gap:6px; align-items:center; font-size:12px; color: var(--muted);">
        Debug indices
        <input type="checkbox" id="debugIdx" />
      </label>
      <button class="primary" id="newGameBtn">New game</button>
      <button id="wonderBtn">Use Leader</button>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="panel tableauPanel">
      <div class="hd">
        <div style="display:flex; gap:10px; align-items:center;">
          <span class="pill" id="agePill">Age</span>
          <span class="pill" id="turnPill">Turn</span>
          <span class="pill" id="actionPill">Picks</span>
        </div>
      </div>
      <div class="bd">
        <div class="tableau" id="tableau"></div>
      </div>
    </section>

    <aside class="panel">
      <div class="hd">
        <div style="display:flex; gap:10px; align-items:center;">
          <span class="pill ok">Human</span>
          <span class="pill warn">AI</span>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="logOpenBtn" class="ghost" title="Open the log">Log</button>
          <button class="primary" id="wonderBtnSide" title="Use the Leader">Leader</button>
          <div class="pill" id="scorePill">Score: –</div>
        </div>
      </div>
      <div class="bd">
        <div class="box compareWrap">
          <table class="compareTable">
            <thead>
              <tr>
                <th></th>
                <th>Human Cards</th>
                <th>AI Cards</th>
              </tr>
            </thead>
            <tbody id="compareBody"></tbody>
          </table>
        </div>
        <div class="hr logInline"></div>
        <div class="box" id="logBox">
          <div class="logHead">
            <h3 style="margin:0;">Log</h3>
            <button id="logCloseBtn" class="ghost" title="Close log">Close</button>
          </div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </aside>
  </div>
</main>

<div id="modalOverlay" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,.36); z-index: 999; align-items:start; justify-content:center; padding: 12px;">
  <div style="max-width: 420px; width:100%; background: rgba(17,24,39,.78); border:1px solid rgba(255,255,255,.16); border-radius: 14px; box-shadow: 0 22px 60px rgba(0,0,0,.65); padding: 12px;">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:6px;">
      <div style="font-weight:700; letter-spacing:.15px; font-size: 13.5px;">Transition to the Modern Age</div>
      <div class="pill" style="border-color: rgba(56,189,248,.35); color: rgba(56,189,248,.95); font-size:12px;">One-time choice</div>
    </div>
    <div style="color: rgba(229,231,235,.92); font-size: 12.75px; line-height: 1.35;">
      <b>Modern Age:</b> you would start <b>second</b>. Discard your <b>Leader</b> to take the <b>first turn</b>?
      <div class="note" style="margin-top:6px;">Turn order only (no “2 picks” bonus).</div>
    </div>
    <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:10px;">
      <button id="modalNoBtn" style="padding: 7px 9px; min-height: 32px;">No</button>
      <button class="primary" id="modalYesBtn" style="padding: 7px 9px; min-height: 32px;">Yes, discard the Leader</button>
    </div>
  </div>
</div>



<div id="kingOverlay">
  <div class="panelBox">
    <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:12px; margin-bottom:8px;">
      <div>
        <div id="kingTitle" style="font-weight:750; letter-spacing:.15px; font-size: 14.5px;">King Wonder</div>
        <div id="kingMsg" class="kingHint"></div>
        <div id="kingReq" class="kingReq"></div>
      </div>
      <div class="pill" style="border-color: rgba(56,189,248,.35); color: rgba(56,189,248,.95); font-size:12px;">Required</div>
    </div>

    <div id="kingCardsGrid" class="miniGrid"></div>
    <div id="kingErr" class="kingErr"></div>

    <div class="kingActions">
      <button class="primary" id="kingConfirmBtn" disabled>Confirm</button>
    </div>
  </div>
</div>


<div id="logBackdrop" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,.65); z-index: 65;"></div>

<div id="endOverlay" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,.62); z-index: 70; align-items:center; justify-content:center; padding: 18px;">
  <div style="max-width: 720px; width:100%; background: rgba(17,24,39,.50); border:1px solid rgba(255,255,255,.14); border-radius: 18px; box-shadow: 0 22px 60px rgba(0,0,0,.60); padding: 14px;">
    <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:12px; margin-bottom:10px;">
      <div>
        <div style="font-weight:750; letter-spacing:.2px; font-size: 15px;">Game over</div>
        <div id="endScoreLine" style="color: rgba(229,231,235,.86); font-size: 13px; margin-top:2px;">—</div>
      </div>
      <button id="endCloseBtn" aria-label="Close results">Close</button>
    </div>

    <div id="endBody" style="color: rgba(229,231,235,.92); font-size: 13px; line-height: 1.35;"></div>

    <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:12px;">
      <button class="primary" id="endNewBtn">New game</button>
    </div>
  </div>
</div>

<script>

/* ============================================================
   0) EXPERIMENT CONSTANTS (AI performance / quality)
   ============================================================ */

// As requested: you can change these values and experiment.
const MC_SIMS = 100;              // simulations per move (Monte Carlo)
const MC_PLAYOUT = "greedy";      // "greedy" or "random"
const JOKER_SWAP_GRANTS_DOUBLE = false; // Modern start: using the Joker to become first also grants 2 picks? (default: no)

/* ============================================================
   1) TABLEAU STRUCTURE (Mirus 2.0)
   ============================================================

   We separate UI from logic:
   - layout.rows: how to draw the tableau (rows, visual order).
   - layout.blockers[i]: list of indices that COVER slot i. Slot i is accessible if ALL blockers are removed.
   - layout.facePattern[i]: "F" face-up, "B" face-down.

   Ancient tableau (20): 2–3–4–5–6 with alternating F/B rows (as in the rules diagram).
   Modern tableau  (24): 2–4–5–6–7 with alternating F/B rows (as in the rules diagram).
*/

function buildRows(rowLens){
  let idx = 0;
  const rows = [];
  for (const len of rowLens){
    const r = [];
    for (let i=0;i<len;i++) r.push(idx++);
    rows.push(r);
  }
  return rows;
}

function buildBlockers(rows){
  const total = rows.reduce((a,r)=>a+r.length,0);
  const blockers = Array.from({length:total}, ()=>[]);

  for (let ri=0; ri<rows.length-1; ri++){
    const upper = rows[ri];
    const lower = rows[ri+1];
    const u = upper.length;
    const l = lower.length;

    for (let lj=0; lj<l; lj++){
      const lowerIdx = lower[lj];
      let upperCols;

      // Standard pyramid step: each upper card covers two adjacent lower cards.
      if (u === l - 1){
        upperCols = [lj-1, lj];
      }
      // Special Modern top step (2 -> 4): each upper covers a pair of cards.
      else if (u === 2 && l === 4){
        upperCols = [Math.floor(lj/2)];
      }
      // Fallback (should not be reached with the current official layouts).
      else {
        const ratio = l / u;
        upperCols = [Math.min(u-1, Math.floor(lj / ratio))];
      }

      for (const uc of upperCols){
        if (uc>=0 && uc<u) blockers[lowerIdx].push(upper[uc]);
      }
    }
  }
  return blockers;
}

function buildFacePattern(rows){
  const total = rows.reduce((a,r)=>a+r.length,0);
  const pat = Array(total);
  for (let ri=0; ri<rows.length; ri++){
    const faceDown = (ri % 2 === 1); // 2nd, 4th, ... rows are face-down
    for (const idx of rows[ri]) pat[idx] = faceDown ? "B" : "F";
  }
  return pat;
}

const LAYOUTS = (()=>{
  const ancientRows = buildRows([2,3,4,5,6]);
  const modernRows  = buildRows([2,4,5,6,7]);

  function rowMultipliersFor(rows){
    // Align the 2-card top row between the cards of the row below (3 in Ancient, 4 in Modern).
    const belowLen = rows[1].length;
    const top = [0.5, belowLen - 1.5];
    return [top].concat(Array(rows.length-1).fill(null));
  }

  const ancient = {
    rows: ancientRows,
    rowColMultipliers: rowMultipliersFor(ancientRows),
    blockers: buildBlockers(ancientRows),
    facePattern: buildFacePattern(ancientRows)
  };
  const modern = {
    rows: modernRows,
    rowColMultipliers: rowMultipliersFor(modernRows),
    blockers: buildBlockers(modernRows),
    facePattern: buildFacePattern(modernRows)
  };
  return {ancient, modern};
})();

function layoutForAge(age){
  return (age === "modern") ? LAYOUTS.modern : LAYOUTS.ancient;
}


// ============================================================
// 1.b) GEOMETRIA TABLEAU (dipende da CSS vars, quindi va ricalcolata)
// ============================================================

function _cssNum(varName, fallback){
  const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : fallback;
}

function getTableauMetrics(){
  // Questi sono aggiornati da fitTableau()
  const cardW = _cssNum("--cardW", 72);
  const cardH = _cssNum("--cardH", 96);
  const colGap = _cssNum("--colGap", 10);

  // Overlap SOLO verticale: passo X >= cardW (nessun overlap), passo Y < cardH (leggero overlap)
  const stepX = cardW + colGap;
  const stepY = cardH * 0.72;

  return { cardW, cardH, stepX, stepY };
}

function computeTableauGeometry(metrics, layout){
  const { cardW, cardH, stepX, stepY } = metrics;

  let maxW = 0;

  const rows = layout.rows;
  const rowMuls = layout.rowColMultipliers;

  const rowW = rows.map((r, ri) => {
    const muls = rowMuls?.[ri];
    const minMul = muls ? Math.min(...muls) : 0;
    const maxMul = muls ? Math.max(...muls) : (r.length - 1);

    const w = cardW + Math.max(0, (maxMul - minMul)) * stepX;
    maxW = Math.max(maxW, w);
    return w;
  });

  const pos = Array(layout.blockers.length);

  for (let ri = 0; ri < rows.length; ri++){
    const row = rows[ri];
    const muls = rowMuls?.[ri];
    const minMul = muls ? Math.min(...muls) : 0;

    const baseX = Math.round((maxW - rowW[ri]) / 2);
    const startX = Math.round(baseX);

    const y = Math.round(ri * stepY);

    for (let ci = 0; ci < row.length; ci++){
      const idx = row[ci];
      const m = muls ? muls[ci] : ci; // <— qui la magia
      pos[idx] = { x: startX + (m - minMul) * stepX, y, row: ri, col: ci };
    }
  }

  const height = cardH + Math.max(0, rows.length - 1) * stepY;
  return { pos, width: maxW, height };
}

/* ============================================================
   2) MODELLO CARTE E SCORING (logica pura)
   ============================================================ */

const SUITS = ["S","D","H","C"];
const SUIT_ICON = {S:"♠", D:"♦", H:"♥", C:"♣"};
const SUIT_NAME = {S:"Military", D:"Culture", H:"Technology", C:"Food"};
// Card-face short labels (4 letters, uppercase) for better readability on small cards.
const SUIT_ABBR = {S:"MILI", D:"CULT", H:"TECH", C:"FOOD"};

function randInt(n){ return Math.floor(Math.random() * n); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=randInt(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function makeAgeDeck(age){
  const deck = [];
  const from = (age==="ancient") ? 1 : 6;
  const to   = (age==="ancient") ? 5 : 10;
  for(let v=from; v<=to; v++){
    for(const s of SUITS){
      deck.push({kind:"card", age, suit:s, value:v, id: `${age}_${s}_${v}`});
    }
  }
  if (age === "modern"){
    // Kings are Wonders. They are NOT part of any suit for sums/sequences,
    // but we keep a suit purely for display (e.g., "K♥").
    for (const s of SUITS){
      deck.push({kind:"king", age, suit:s, value:13, id: `${age}_K_${s}`});
    }
  }
  shuffle(deck);
  return deck;
}

function effectiveCardValue(card, wonderMods){
  if (!card || card.kind!=="card") return card ? card.value : 0;
  if (!wonderMods) return card.value;
  for (let p=0; p<2; p++){
    const wm = wonderMods[p];
    if (!wm) continue;
    if (wm.cardId === card.id && typeof wm.delta === "number") return card.value + wm.delta;
  }
  return card.value;
}

function sumSuit(cards, suit, wonderMods=null){
  let s=0;
  for(const c of cards){
    if (c.kind==="card" && c.suit===suit) s += effectiveCardValue(c, wonderMods);
  }
  return s;
}
function valuesSet(cards, suit, wonderMods=null){
  const set = new Set();
  for(const c of cards){
    if (c.kind!=="card" || c.suit!==suit) continue;
    const v = effectiveCardValue(c, wonderMods);
    if (v>=1 && v<=10) set.add(v);
  }
  return set;
}

function valueLabel(v){
  return (v===1) ? "A" : String(v);
}
function suitValues(cards, suit){
  return cards
    .filter(c => c && c.kind==="card" && c.suit===suit)
    .map(c => c.value)
    .sort((a,b)=>a-b);
}
function countValue(cards, value){
  let k=0; for(const c of cards){ if (c.kind==="card" && c.value===value) k++; } return k;
}
function hasAllFourOfValue(cards, value){
  const suits = new Set();
  for(const c of cards){ if (c.kind==="card" && c.value===value) suits.add(c.suit); }
  return suits.size===4;
}
function countKingsInCards(cards){
  let k = 0;
  for (const c of cards){ if (c && c.kind === "king") k++; }
  return k;
}
function wonderTieOwner(hCards, aCards){
  const hHasWonder = countKingsInCards(hCards) >= 3;
  const aHasWonder = countKingsInCards(aCards) >= 3;
  if (hHasWonder && !aHasWonder) return 0;
  if (aHasWonder && !hHasWonder) return 1;
  return null;
}

// Segmenti massimali di consecutivi su cerchio 1..10 (wrap 10->1).
function circularRuns(values){
  const present = Array(11).fill(false);
  for(const v of values) present[v]=true;

  const missing = [];
  for(let v=1; v<=10; v++) if (!present[v]) missing.push(v);
  if (missing.length===0) return [{len:10, maxCard:10, cards:[1,2,3,4,5,6,7,8,9,10]}];

  const start = (missing[0] % 10) + 1;
  const seq = [];
  for(let i=0;i<10;i++){
    const v = ((start + i - 1) % 10) + 1;
    seq.push(present[v] ? v : 0);
  }

  const runs = [];
  let cur = [];
  for(const v of seq){
    if (v!==0) cur.push(v);
    else{
      if (cur.length>0){
        runs.push({len:cur.length, maxCard: Math.max(...cur), cards:cur.slice()});
        cur=[];
      }
    }
  }
  if (cur.length>0) runs.push({len:cur.length, maxCard: Math.max(...cur), cards:cur.slice()});
  return runs;
}

function bestDiamondStraight(cards, wonderMods=null){
  const set = valuesSet(cards,"D", wonderMods);
  const runs = circularRuns(set);
  if (runs.length===0) return {len:0, maxCard:0, cards:[]};
  // tie-break: same length => highest card in the straight wins (here interpreted as the max rank present)
  runs.sort((a,b)=> (b.len-a.len) || (b.maxCard-a.maxCard));
  return runs[0];
}

function runKey(run){
  if (!run || !run.cards) return "";
  return run.cards.join(",");
}

function diamondStraights(cards, wonderMods=null){
  const set = valuesSet(cards,"D", wonderMods);
  const runs = circularRuns(set).filter(r=>r.len>=2);
  runs.sort((a,b)=> (b.len-a.len) || (b.maxCard-a.maxCard) || (runKey(b).localeCompare(runKey(a))));
  return runs;
}

function topDiamondStraights(cards, k=2, wonderMods=null){
  return diamondStraights(cards, wonderMods).slice(0,k);
}
function runText(run){
  if (!run || !run.cards || run.cards.length===0) return "—";
  return run.cards.map(valueLabel).join("-");
}
function cultureVP(cards){
  // Legacy (per-player) culture scoring: +8 for best straight, +4 for second.
  // Not used for final scoring anymore (Culture is now CONTESTED across players).
  const runs = topDiamondStraights(cards, 2);
  let vp = 0;
  if (runs[0]) vp += 8;
  if (runs[1]) vp += 4;
  return {vp, runs};
}

function cultureContestVP(hCards, aCards, wonderMods=null){
  // Global, contested Culture (Mirus 2.0): award tiers are assigned across BOTH players' ♦ sequences.
  // Tier 1: +10 to the best sequence (len ≥ 2)
  // Tier 2: +5 to the second-best sequence (len ≥ 2)
  // Tie-breaks: longer length wins; if tie, higher card wins.
  // If both length and high card tie, the tier is shared.
  const hRuns = diamondStraights(hCards, wonderMods);
  const aRuns = diamondStraights(aCards, wonderMods);

  const cand = [];
  for (const r of hRuns){ cand.push({owner:0, run:r, key:`${r.len}|${r.maxCard}`}); }
  for (const r of aRuns){ cand.push({owner:1, run:r, key:`${r.len}|${r.maxCard}`}); }

  cand.sort((x,y)=> (y.run.len-x.run.len) || (y.run.maxCard-x.run.maxCard) || (y.key.localeCompare(x.key)));

  let h = 0, a = 0;
  let bestGroup = [];
  let secondGroup = [];

  const tieOwner = wonderTieOwner(hCards, aCards);

  if (cand.length){
    const bestKey = cand[0].key;
    bestGroup = cand.filter(c=>c.key===bestKey);
    if (tieOwner!==null && bestGroup.some(c=>c.owner===0) && bestGroup.some(c=>c.owner===1)){
      bestGroup = bestGroup.filter(c=>c.owner===tieOwner);
    }
    for (const c of bestGroup){
        if (c.owner===0) h += 10; else a += 10;
    }

    const rest = cand.filter(c=>c.key!==bestKey);
    if (rest.length){
      const secondKey = rest[0].key;
      secondGroup = rest.filter(c=>c.key===secondKey);
      if (tieOwner!==null && secondGroup.some(c=>c.owner===0) && secondGroup.some(c=>c.owner===1)){
        secondGroup = secondGroup.filter(c=>c.owner===tieOwner);
      }
      for (const c of secondGroup){
          if (c.owner===0) h += 5; else a += 5;
      }
    }
  }

  return {h, a, hRuns, aRuns, bestGroup, secondGroup};
}

function techPoints(cards, wonderMods=null){
  const set = valuesSet(cards,"H", wonderMods);
  const runs = circularRuns(set);
  let best = 0;
  for (const r of runs) if (r.len>best) best = r.len;
  return (best>=3) ? (2*best) : 0;
}
function foodPoints(cards, wonderMods=null){
  return Math.floor(sumSuit(cards,"C", wonderMods)/5);
}

function ancientScoring(hAnc, aAnc, wonderMods=null){
  let h=0, a=0;
  const hs = sumSuit(hAnc,"S", wonderMods);
  const as = sumSuit(aAnc,"S", wonderMods);
  if (hs>as) h+=4; else if (as>hs) a+=4;
  if (hasAllFourOfValue(hAnc,5)) h-=3;
  if (hasAllFourOfValue(aAnc,5)) a-=3;
  return {human:h, ai:a, detail:{hs,as}};
}

function modernScoring(allH, allA, wonderMods=null){
  let h=0, a=0;
  const hs = sumSuit(allH,"S", wonderMods);
  const as = sumSuit(allA,"S", wonderMods);
  const tieOwner = wonderTieOwner(allH, allA);
  if (hs>as) h+=8;
  else if (as>hs) a+=8;
  else if (tieOwner===0) h+=8;
  else if (tieOwner===1) a+=8;

  h += foodPoints(allH, wonderMods); a += foodPoints(allA, wonderMods);


  const cult = cultureContestVP(allH, allA, wonderMods);
  h += cult.h;
  a += cult.a;

  h += techPoints(allH, wonderMods);
  a += techPoints(allA, wonderMods);

  if (hasAllFourOfValue(allH,10)) h-=6;
  if (hasAllFourOfValue(allA,10)) a-=6;

  return {human:h, ai:a, detail:{hs,as,cult}};
}

function totalScoring(allH, allA, wonderMods=null){
  const hAnc = allH.filter(c=>c.age==="ancient");
  const aAnc = allA.filter(c=>c.age==="ancient");
  const anc = ancientScoring(hAnc, aAnc, wonderMods);
  const mod = modernScoring(allH, allA, wonderMods);
  return {
    human: anc.human + mod.human,
    ai: anc.ai + mod.ai,
    detail: {anc, mod}
  };
}

/* ============================================================
   3) ENGINE (state + rules) – without DOM, with private “secrets”
   ============================================================ */

const Engine = (() => {
  // “Public” state: what UI and AI can read.
  // “Secret” state: identity of face-down cards, accessible only to the engine.

  function initTableau(age){
    const layout = layoutForAge(age);
    const deck = makeAgeDeck(age);
    if (deck.length !== layout.blockers.length) throw new Error("Deck size mismatch.");

    // Public slots: {removed, faceDown, card?} with `card` populated only if face-up.
    const slots = Array.from({length:deck.length}, (_,i)=>({
      idx:i,
      removed:false,
      faceDown: (layout.facePattern[i]==="B"),
      card: null
    }));

    // Secrets: the true identity of each slot (always known to the engine).
    const secret = deck.slice();

    // Make face-up cards visible.
    for(let i=0;i<deck.length;i++){
      if (!slots[i].faceDown) slots[i].card = secret[i];
    }

    return {slots, secret};
  }

  function isAccessible(pub, idx){
    if (pub.slots[idx].removed) return false;

    // Bottom-up accessibility: a card is accessible only if all cards it covers are removed.
    const blockers = layoutForAge(pub.age).blockers;
    for(let j=0;j<pub.slots.length;j++){
      if (pub.slots[j].removed) continue;
      const bl = blockers[j] || [];
      for(let k=0;k<bl.length;k++){
        if (bl[k] === idx) return false;
      }
    }
    return true;
  }

  function revealAccessible(pub, secret){
    let flipped = 0;
    for(let i=0;i<pub.slots.length;i++){
      const s = pub.slots[i];
      if (s.removed) continue;
      if (s.faceDown && isAccessible(pub, i)){
        s.faceDown = false;
        s.card = secret[i];
        flipped++;
      }
    }
    return flipped;
  }

  function newGame(startingPlayer){
    const {slots, secret} = initTableau("ancient");
    const pub = {
      age: "ancient",
      currentPlayer: (startingPlayer==="human") ? 0 : 1,
      ancientSecondPlayer: (startingPlayer==="human") ? 1 : 0,
      picksLeftThisTurn: 1,
      jokerUsed: [false,false],
      modernSwapStillAvailable: false, // settato quando si entra in modern
      kingWonder: null, // active while resolving Wonder mark / final +/-1 choice
      wonderMark: [
        { cardId:null, cardBaseValue:null, pending:false, delta:0, finalChoicePending:false },
        { cardId:null, cardBaseValue:null, pending:false, delta:0, finalChoicePending:false }
      ],
      slots,
      taken: [[],[]],
      score: {human:0, ai:0},
      ended: false
    };

    revealAccessible(pub, secret);
    return {pub, secret};
  }

  function canUseJokerDouble(pub, player){
    return (!pub.kingWonder) && (!pub.jokerUsed[player]) && (pub.currentPlayer===player) && (pub.picksLeftThisTurn===1) && !pub.ended;
  }

  function useJokerDouble(state){
    const {pub} = state;
    const p = pub.currentPlayer;
    if (!canUseJokerDouble(pub,p)) return {ok:false, msg:"Leader cannot be used right now."};
    pub.jokerUsed[p] = true;
    pub.picksLeftThisTurn = 2;
    return {ok:true};
  }

  function canUseModernSwap(pub, player){
    // Solo nel passaggio Ancient->Modern, prima di qualunque presa Modern; e solo per chi sarebbe il SECONDO nella Modern Age.
    if (pub.kingWonder) return false;
    if (pub.age !== "modern") return false;
    if (!pub.modernSwapStillAvailable) return false;
    if (pub.jokerUsed[player]) return false;

    const modernFirst = pub.ancientSecondPlayer;
    const modernSecond = 1 - modernFirst;
    if (player !== modernSecond) return false;

    const anyModernTaken = pub.taken[0].concat(pub.taken[1]).some(c=>c.age==="modern");
    if (anyModernTaken) return false;

    return true;
  }

  function useModernSwap(state, player){
    const {pub} = state;
    if (!canUseModernSwap(pub, player)) return {ok:false, msg:"Choice not available."};

    pub.jokerUsed[player] = true;
    pub.modernSwapStillAvailable = false;

    // Beneficio: SOLO cambio dell'ordine. Nessuna doppia presa.
    pub.currentPlayer = player;
    pub.picksLeftThisTurn = 1;

    return {ok:true};
  }

  function countKings(cards){
    let k=0; for (const c of cards) if (c && c.kind==="king") k++;
    return k;
  }

  function removeCardById(arr, id){
    const i = arr.findIndex(c=>c && c.id===id);
    if (i<0) return null;
    return arr.splice(i,1)[0] || null;
  }

  function pickOfferCardsAI(nonKingCards, maxOffer, reqModern){
    const modern = nonKingCards.filter(c=>c.age==="modern").slice().sort((a,b)=>a.value-b.value);
    const ancient = nonKingCards.filter(c=>c.age==="ancient").slice().sort((a,b)=>a.value-b.value);
    const offered = [];
    // must include as many Modern as possible (reqModern)
    for (let i=0;i<Math.min(reqModern, modern.length);i++) offered.push(modern[i]);
    // fill with the lowest remaining
    let iM = reqModern;
    while (offered.length < maxOffer && iM < modern.length){ offered.push(modern[iM++]); }
    let iA = 0;
    while (offered.length < maxOffer && iA < ancient.length){ offered.push(ancient[iA++]); }
    return offered.slice(0, maxOffer);
  }

  function pickBestFromOfferAI(offered){
    // Simple heuristic aligned with final scoring weights (not perfect, but deterministic).
    function wSuit(s){
      if (s==="S") return 3.0;
      if (s==="H") return 2.6;
      if (s==="D") return 2.4;
      if (s==="C") return 1.9;
      return 1.0;
    }
    let best = offered[0], bestScore = -1e9;
    for (const c of offered){
      if (!c || c.kind!=="card") continue;
      const score = c.value * wSuit(c.suit);
      if (score > bestScore){ bestScore = score; best = c; }
    }
    return best;
  }

  function wonderModsFromState(pub){
    return [0,1].map(p=>{
      const wm = pub.wonderMark[p] || {};
      return {cardId: wm.cardId || null, delta: Number(wm.delta)||0};
    });
  }

  function startKingWonder(state, builder){
    const {pub} = state;
    const ownCards = pub.taken[builder].filter(c=>c && c.kind==="card");
    if (!ownCards.length) return {started:false};

    pub.kingWonder = {
      phase: "mark",
      builder,
      eligibleIds: ownCards.map(c=>c.id),
      pendingFinalize: true
    };
    pub.wonderMark[builder].pending = true;
    return {started:true};
  }

  function finalizeAfterTake(state){
    const {pub, secret} = state;
    const flipped = revealAccessible(pub, secret);

    // End of age?
    if (pub.slots.every(x=>x.removed)){
      if (pub.age === "ancient"){
        const hAnc = pub.taken[0].filter(c=>c.age==="ancient");
        const aAnc = pub.taken[1].filter(c=>c.age==="ancient");
        const sc = ancientScoring(hAnc, aAnc, wonderModsFromState(pub));
        pub.score.human += sc.human;
        pub.score.ai += sc.ai;

        // Move to Modern
        const next = initTableau("modern");
        pub.age = "modern";
        pub.slots = next.slots;
        state.secret = next.secret;

        pub.currentPlayer = pub.ancientSecondPlayer;
        pub.picksLeftThisTurn = 1;
        pub.modernSwapStillAvailable = true;

        // No face-down cards are accessible at setup, but keep it consistent.
        revealAccessible(pub, state.secret);

        return {ok:true, endedAge:true, flipped};
      } else {
        const allH = pub.taken[0];
        const allA = pub.taken[1];
        const pendingFinal = [0,1].find(p=>{
          const wm = pub.wonderMark[p];
          return wm && wm.cardId && wm.finalChoicePending;
        });
        if (typeof pendingFinal === "number"){
          pub.kingWonder = {
            phase: "finalChoice",
            builder: pendingFinal,
            eligibleDelta: [-1,0,1],
            pendingFinalize: true
          };
          if (pendingFinal===1 && !state.__sim){
            return autoResolveKingWonder(state);
          }
          return {ok:true, pendingKingWonder:true, flipped};
        }

        const sc = modernScoring(allH, allA, wonderModsFromState(pub));
        pub.score.human += sc.human;
        pub.score.ai += sc.ai;
        pub.ended = true;
        return {ok:true, endedGame:true, flipped};
      }
    }

    // End of turn
    if (pub.picksLeftThisTurn <= 0){
      pub.picksLeftThisTurn = 1;
      pub.currentPlayer = 1 - pub.currentPlayer;
    }

    // Disable the Modern swap after the first Modern pick (if not already)
    if (pub.age==="modern" && pub.modernSwapStillAvailable){
      const anyModernTaken = pub.taken[0].concat(pub.taken[1]).some(c=>c.age==="modern");
      if (anyModernTaken) pub.modernSwapStillAvailable = false;
    }

    return {ok:true, flipped};
  }

  function submitKingWonderOffer(state, selectedIds){
    const {pub} = state;
    const kw = pub.kingWonder;
    if (!kw || kw.phase !== "mark") return {ok:false, msg:"No Wonder mark is pending."};
    if (pub.ended) return {ok:false, msg:"Game over."};

    const uniq = Array.from(new Set(selectedIds||[]));
    if (uniq.length !== 1) return {ok:false, msg:"Select exactly 1 card to mark."};

    const eligible = new Set(kw.eligibleIds);
    const chosenId = uniq[0];
    if (!eligible.has(chosenId)) return {ok:false, msg:"Invalid mark (choose one of your own non-King cards)."};

    const ownCards = pub.taken[kw.builder];
    const marked = ownCards.find(c=>c && c.id===chosenId && c.kind==="card");
    if (!marked) return {ok:false, msg:"Invalid mark."};

    pub.wonderMark[kw.builder] = {
      cardId: marked.id,
      cardBaseValue: marked.value,
      pending: false,
      delta: 0,
      finalChoicePending: true
    };

    pub.kingWonder = null;
    const res = finalizeAfterTake(state);
    res.markedCard = marked;
    return res;
  }

  function chooseKingWonder(state, chosenId, _internal=false){
    const {pub} = state;
    const kw = pub.kingWonder;
    if (!kw || kw.phase !== "finalChoice") return {ok:false, msg:"No Wonder final choice is pending."};
    if (pub.ended) return {ok:false, msg:"Game over."};
    const delta = Number(chosenId);
    if (![-1,0,1].includes(delta)) return {ok:false, msg:"Invalid final value choice."};
    const builder = kw.builder;
    const wm = pub.wonderMark[builder];
    if (!wm || !wm.cardId) return {ok:false, msg:"Missing marked card."};

    wm.delta = delta;
    wm.finalChoicePending = false;
    pub.kingWonder = null;
    const allH = pub.taken[0];
    const allA = pub.taken[1];
    const sc = modernScoring(allH, allA, wonderModsFromState(pub));
    pub.score.human += sc.human;
    pub.score.ai += sc.ai;
    pub.ended = true;
    const res = {ok:true, endedGame:true, flipped:0};
    res.kingWonderDelta = delta;
    res.kingWonderCardId = wm.cardId;
    res._internal = _internal;
    return res;
  }


  function autoResolveKingWonder(state){
    const {pub} = state;
    const kw = pub.kingWonder;
    if (!kw) return finalizeAfterTake(state);

    if (kw.phase === "mark"){
      const ownCards = pub.taken[kw.builder].filter(c=>c && c.kind==="card");
      if (!ownCards.length){
        pub.kingWonder = null;
        return finalizeAfterTake(state);
      }
      const chosen = pickBestFromOfferAI(ownCards);
      return submitKingWonderOffer(state, [chosen.id]);
    }

    if (kw.phase === "finalChoice"){
      const scores = [-1,0,1].map(delta=>{
        const tmp = (typeof structuredClone === "function") ? structuredClone(pub) : JSON.parse(JSON.stringify(pub));
        tmp.wonderMark[kw.builder].delta = delta;
        const t = totalScoring(tmp.taken[0], tmp.taken[1], wonderModsFromState(tmp));
        return {delta, val: t.ai - t.human};
      });
      scores.sort((a,b)=>b.val-a.val || b.delta-a.delta);
      return chooseKingWonder(state, scores[0].delta, true);
    }

    return finalizeAfterTake(state);
  }

  function take(state, idx){
    const {pub, secret} = state;
    if (pub.ended) return {ok:false, msg:"Game over."};
    if (pub.kingWonder) return {ok:false, msg:"Resolve the King Wonder first."};
    const s = pub.slots[idx];
    if (s.removed) return {ok:false, msg:"Already removed."};
    if (s.faceDown) return {ok:false, msg:"Face-down card (it should reveal itself when it becomes accessible)."};
    if (!isAccessible(pub, idx)) return {ok:false, msg:"Not accessible."};

    const p = pub.currentPlayer;
    const beforeKings = countKings(pub.taken[p]);

    s.removed = true;
    pub.taken[p].push(s.card);
    pub.picksLeftThisTurn -= 1;

    // King Wonder: immediately after taking your 3rd King, before revealing newly accessible cards.
    if (pub.age === "modern" && s.card && s.card.kind==="king"){
      const afterKings = beforeKings + 1;
      if (afterKings === 3){
        const kw = startKingWonder(state, p);
        if (kw.started){
          if (state.__sim) return autoResolveKingWonder(state);
          return {ok:true, pendingKingWonder:true};
        }
      }
    }

    return finalizeAfterTake(state);
  }

  function getPublicView(state){
    // Copia shallow sicura: AI e UI non devono ottenere reference ai segreti.
    // Note: for simplicity, we return a deep copy via structuredClone if available.
    if (typeof structuredClone === "function") return structuredClone(state.pub);
    return JSON.parse(JSON.stringify(state.pub));
  }

  function unknownPoolForAI(publicView){
    // “Fair”: unknown pool = current-age deck minus seen/taken cards.
    const age = publicView.age;
    // the unknown pool also includes face-down cards in the current age (which the AI cannot see)
    const deck = makeAgeDeck(age).map(c=>c.id); // shuffle irrilevante qui
    const known = new Set();

    for(const sl of publicView.slots){
      if (sl.removed && sl.card) known.add(sl.card.id);
      if (!sl.removed && !sl.faceDown && sl.card) known.add(sl.card.id);
    }
    for(const c of publicView.taken[0]) if (c.age===age) known.add(c.id);
    for(const c of publicView.taken[1]) if (c.age===age) known.add(c.id);

    const remaining = deck.filter(id => !known.has(id));
    return remaining;
  }

  return {
    newGame, take,
    useJokerDouble, canUseJokerDouble,
    useModernSwap, canUseModernSwap,
    submitKingWonderOffer, chooseKingWonder,
    isAccessible,
    getPublicView, unknownPoolForAI
  };
})();

/* ============================================================
   4) AI (uses ONLY public view + unknown pool)
   ============================================================ */

function quickEval(publicView, perspective){
  // Quick heuristic for greedy/rollout: potential difference on suits/straight.
  const me = publicView.taken[perspective];
  const opp = publicView.taken[1-perspective];

  const wS = (publicView.age==="ancient") ? 0.6 : 0.8;
  const wC = 0.25, wD = 1.2, wH = 1.0;

  const dS = (sumSuit(me,"S") - sumSuit(opp,"S")) * wS;
  const dC = (sumSuit(me,"C") - sumSuit(opp,"C")) * wC;
  const cult = cultureContestVP(me, opp);
  const dD = (cult.h - cult.a) * wD;
  const dH = (techPoints(me) - techPoints(opp)) * wH;

  const pen = 0.6 * (Math.max(0, countValue(me,5)-2) + Math.max(0, countValue(me,10)-2));
  return dS + dC + dD + dH - pen;
}

function enumerateMoves(publicView, player){
  if (publicView.kingWonder){
    const kw = publicView.kingWonder;
    if (kw.builder !== player) return [{type:"pass"}];
    if (kw.phase === "mark"){
      const ids = Array.isArray(kw.eligibleIds) ? kw.eligibleIds : [];
      if (ids.length===0) return [{type:"pass"}];
      return ids.map(id => ({type:"kingMark", id}));
    }
    if (kw.phase === "finalChoice"){
      return [-1,0,1].map(delta => ({type:"kingDelta", delta}));
    }
    return [{type:"pass"}];
  }

  const moves = [];
  // Modern-start swap (only if the player is eligible)
  if (Engine.canUseModernSwap(publicView, player)) moves.push({type:"modernSwap"});

  // Joker double
  if (Engine.canUseJokerDouble(publicView, player)) moves.push({type:"wonder"});

  // Take
  for(let i=0;i<publicView.slots.length;i++){
    const s = publicView.slots[i];
    if (s.removed) continue;
    if (s.faceDown) continue;
    if (Engine.isAccessible(publicView, i)) moves.push({type:"take", idx:i});
  }
  if (moves.length===0) moves.push({type:"pass"});
  return moves;
}

function aiChoose(state){
  const level = document.getElementById("aiLevel").value;
  if (level==="random") return aiRandom(state);
  if (level==="greedy") return aiGreedy(state);
  return aiMonteCarlo(state);
}

function aiRandom(state){
  const pv = Engine.getPublicView(state);
  const moves = enumerateMoves(pv, 1);
  return moves[randInt(moves.length)];
}

function aiGreedy(state){
  const pv = Engine.getPublicView(state);
  const moves = enumerateMoves(pv, 1);
  let best = moves[0], bestScore = -1e9;

  for(const mv of moves){
    const score = estimateMoveValue(state, mv);
    if (score > bestScore){ bestScore = score; best = mv; }
  }
  return best;
}

function estimateMoveValue(state, mv){
  // Apply on an engine copy to estimate, without DOM.
  const sim = cloneEngineStateForSim(state);
  applyAIMoveToSim(sim, mv);
  const pv2 = Engine.getPublicView(sim);
  return quickEval(pv2, 1) + 0.08 * countVisibleAccessible(pv2);
}

function countVisibleAccessible(pv){
  let k=0;
  for(let i=0;i<pv.slots.length;i++){
    const s = pv.slots[i];
    if (!s.removed && !s.faceDown && Engine.isAccessible(pv, i)) k++;
  }
  return k;
}

function cloneEngineStateForSim(state){
  // Per simulazioni: duplichiamo sia pub che secret.
  // Note: here it is OK to duplicate secrets because it is the “ground truth” of the world. But Monte Carlo reshuffles face-down cards using the unknown pool.
  let sim;
  if (typeof structuredClone==="function") sim = structuredClone(state);
  else sim = JSON.parse(JSON.stringify(state));
  sim.__sim = true;
  return sim;
}

function aiMonteCarlo(state){
  const pv = Engine.getPublicView(state);
  const moves = enumerateMoves(pv, 1);
  let best = moves[0], bestVal = -1e9;

  // unknown pool: list of card.id (of the current age) that are not known to the AI
  const poolIds = Engine.unknownPoolForAI(pv);

  for(const mv of moves){
    let acc = 0;
    const sims = MC_SIMS;
    for(let k=0;k<sims;k++){
      const sim = cloneEngineStateForSim(state);

      // “Fair sampling”: reassign face-down cards in the current age using only poolIds (without reading the real identities).
      // Implementation: rebuild an id->card mapping for that age, then fill secrets for faceDown slots with a random permutation.
      const age = sim.pub.age;
      const fullDeck = makeAgeDeck(age);
      const idToCard = new Map(fullDeck.map(c=>[c.id,c]));

      const pool = poolIds.slice();
      shuffle(pool);

      let pi = 0;
      for(let i=0;i<sim.pub.slots.length;i++){
        const sl = sim.pub.slots[i];
        if (sl.removed) continue;
        if (sl.faceDown){
          const id = pool[pi++];
          sim.secret[i] = idToCard.get(id);
          // resta nascosta nel public
          sl.card = null;
        } else {
          // se faceUp, anche in public deve avere card coerente col secret
          // (but in the sim, face-up cards already have a card; we keep it)
        }
      }

      // applica mossa candidata e poi playout veloce fino alla fine
      applyAIMoveToSim(sim, mv);
      playoutSim(sim);

      // valore: score ai - score human
      acc += (sim.pub.score.ai - sim.pub.score.human);
    }
    const exp = acc / sims;
    if (exp > bestVal){ bestVal = exp; best = mv; }
  }
  return best;
}

function applyAIMoveToSim(sim, mv){
  if (mv.type==="kingMark"){
    Engine.submitKingWonderOffer(sim, [mv.id]);
    return;
  }
  if (mv.type==="kingDelta"){
    Engine.chooseKingWonder(sim, mv.delta, true);
    return;
  }
  if (mv.type==="modernSwap"){
    // decide il secondo della Modern Age (AI = 1)
    Engine.useModernSwap(sim, 1);
    return;
  }
  if (mv.type==="wonder"){
    Engine.useJokerDouble(sim);
    return;
  }
  if (mv.type==="take"){
    Engine.take(sim, mv.idx);
    return;
  }
  if (mv.type==="pass"){
    sim.pub.picksLeftThisTurn = 1;
    sim.pub.currentPlayer = 1 - sim.pub.currentPlayer;
    return;
  }
}

function playoutSim(sim){
  // Fast policy until the game ends.
  let guard = 0;
  while(!sim.pub.ended && guard < 500){
    guard++;
    const player = sim.pub.currentPlayer;
    const pv = Engine.getPublicView(sim);
    const moves = enumerateMoves(pv, player);
    let mv = moves[0];

    if (MC_PLAYOUT==="random"){
      mv = moves[randInt(moves.length)];
    } else {
      // greedy dal punto di vista del player
      let best = moves[0], bestScore = -1e9;
      for(const m of moves){
        const s2 = cloneEngineStateForSim(sim);
        applyAIMoveToSim(s2, m);
        const pv2 = Engine.getPublicView(s2);
        const score = quickEval(pv2, player);
        if (score>bestScore){ bestScore=score; best=m; }
      }
      mv = best;
    }
    applyAIMoveToSim(sim, mv);

    // disable swap after the first Modern pick (if not already)
    if (sim.pub.age==="modern" && sim.pub.modernSwapStillAvailable){
      const anyModernTaken = sim.pub.taken[0].concat(sim.pub.taken[1]).some(c=>c.age==="modern");
      if (anyModernTaken) sim.pub.modernSwapStillAvailable = false;
    }
  }
}

/* ============================================================
   5) UI (solo rendering + input)
   ============================================================ */

let STATE = null;

const elTableau = document.getElementById("tableau");
const elLog = document.getElementById("log");
const elAgePill = document.getElementById("agePill");
const elTurnPill = document.getElementById("turnPill");
const elActionPill = document.getElementById("actionPill");
const elScorePill = document.getElementById("scorePill");
const elStatusLine = document.getElementById("statusLine");
const elCompareBody = document.getElementById("compareBody");
const btnNew = document.getElementById("newGameBtn");
const btnWonder = document.getElementById("wonderBtn");
const btnWonderSide = document.getElementById("wonderBtnSide");
const cbDebug = document.getElementById("debugIdx");

const elModal = document.getElementById("modalOverlay");
const btnModalYes = document.getElementById("modalYesBtn");
const btnModalNo = document.getElementById("modalNoBtn");
let MODAL_OPEN = false;
function openModal(){ MODAL_OPEN = true; elModal.style.display = "flex"; }
function closeModal(){ MODAL_OPEN = false; elModal.style.display = "none"; }


const elKingOverlay = document.getElementById("kingOverlay");
const elKingTitle = document.getElementById("kingTitle");
const elKingMsg = document.getElementById("kingMsg");
const elKingReq = document.getElementById("kingReq");
const elKingGrid = document.getElementById("kingCardsGrid");
const elKingErr = document.getElementById("kingErr");
const btnKingConfirm = document.getElementById("kingConfirmBtn");

let KING_OPEN = false;
let KING_CTX = "";
let KING_SELECTED = new Set();

function openKingOverlay(){
  KING_OPEN = true;
  if (elKingOverlay) elKingOverlay.style.display = "flex";
}
function closeKingOverlay(){
  KING_OPEN = false;
  KING_CTX = "";
  KING_SELECTED.clear();
  if (elKingOverlay) elKingOverlay.style.display = "none";
  if (elKingErr) elKingErr.textContent = "";
}

function _findCardById(id){
  const pub = STATE?.pub;
  if (!pub) return null;
  for (const c of pub.taken[0]) if (c && c.id===id) return c;
  for (const c of pub.taken[1]) if (c && c.id===id) return c;
  return null;
}
function _cardsForIds(ids){
  return (ids||[]).map(_findCardById).filter(Boolean);
}
function _kingCtxKey(kw){
  const b = kw.eligibleIds ? kw.eligibleIds.slice().join(",") : "";
  return `${kw.phase}|${kw.builder}|${b}`;
}
function _modernCount(ids){
  let n = 0;
  for (const id of ids){
    const c = _findCardById(id);
    if (c && c.age==="modern") n++;
  }
  return n;
}

function syncKingOverlay(){
  if (!STATE || !STATE.pub){ if (KING_OPEN) closeKingOverlay(); return; }
  const kw = STATE.pub.kingWonder;
  if (!kw){ if (KING_OPEN) closeKingOverlay(); return; }

  const key = _kingCtxKey(kw);
  if (key !== KING_CTX){
    KING_CTX = key;
    KING_SELECTED.clear();
    if (elKingErr) elKingErr.textContent = "";
  }

  openKingOverlay();
  if (!elKingTitle || !elKingMsg || !elKingReq || !elKingGrid || !btnKingConfirm) return;

  const builderName = playerName(kw.builder);

  if (kw.phase === "mark"){
    elKingTitle.textContent = "King Wonder — Mark a card";
    elKingMsg.innerHTML = `<b>${builderName}</b> has built the Wonder (3rd K). Mark <b>1</b> of ${builderName}'s non-King cards.`;
    elKingReq.textContent = "The card can later be scored at value -1, base, or +1.";

    const cards = _cardsForIds(kw.eligibleIds);
    renderKingCards(cards, kw);
  } else {
    elKingTitle.textContent = "King Wonder — Final value choice";
    elKingMsg.innerHTML = `<b>${builderName}</b>: choose the marked card final value modifier.`;
    elKingReq.textContent = "Valid choices: -1, 0 (base), +1.";

    const markedId = STATE.pub.wonderMark?.[kw.builder]?.cardId;
    const cards = _cardsForIds(markedId ? [markedId] : []);
    renderKingCards(cards, kw);
  }
}

function tuneKingOverlayLayout(cardCount, phase){
  if (!elKingOverlay || !elKingGrid) return;
  const vh = window.innerHeight || 800;
  const vw = window.innerWidth || 400;
  let miniW = 58;
  if (vh <= 740 || vw <= 700) miniW = 52;
  if (vh <= 640) miniW = 46;

  if (phase === "mark"){
    if (cardCount >= 16) miniW -= 8;
    else if (cardCount >= 12) miniW -= 6;
    else if (cardCount >= 9) miniW -= 4;
  } else {
    miniW = Math.max(miniW - 4, 40);
  }

  miniW = Math.max(40, Math.min(60, miniW));
  const miniH = Math.round(miniW * 1.38);
  const gap = miniW <= 46 ? 4 : (miniW <= 52 ? 5 : 6);

  elKingOverlay.style.setProperty('--kingMiniW', `${miniW}px`);
  elKingOverlay.style.setProperty('--kingMiniH', `${miniH}px`);
  elKingOverlay.style.setProperty('--kingGap', `${gap}px`);
}

function renderKingCards(cards, kw){
  if (!elKingGrid || !btnKingConfirm) return;
  elKingGrid.innerHTML = "";

  const phase = kw.phase;
  tuneKingOverlayLayout((cards||[]).length, phase);
  const suitOrder = {S:0, C:1, H:2, D:3};
  const sortedCards = (cards||[]).slice().sort((a,b)=>{
    const s = (suitOrder[a?.suit] ?? 99) - (suitOrder[b?.suit] ?? 99);
    if (s!==0) return s;
    const av = (a?.kind === "king") ? 99 : (a?.value ?? 0);
    const bv = (b?.kind === "king") ? 99 : (b?.value ?? 0);
    if (av!==bv) return av-bv;
    return String(a?.id||"").localeCompare(String(b?.id||""));
  });

  function canSelect(card){
    if (KING_SELECTED.has(card.id)) return true; // always allow deselect
    return KING_SELECTED.size < 1;
  }

  function renderMiniCard(c){
    const el = document.createElement("div");
    el.className = "miniCard";
    if (phase === "finalChoice") el.classList.add("finalChoice");
    if (c && c.suit) el.classList.add("suit" + c.suit);
    if (KING_SELECTED.has(c.id)) el.classList.add("selected");

    const selectable = canSelect(c);
    if (!selectable && !KING_SELECTED.has(c.id)) el.classList.add("disabled");

    const big = document.createElement("div");
    big.className = "big";
    big.textContent = cardLabel(c);

    const small = document.createElement("div");
    small.className = "small";
    small.textContent = (phase === "mark")
      ? ((c.age === "modern") ? "modern" : "ancient")
      : "marked card";

    el.appendChild(small);
    el.appendChild(big);

    el.addEventListener("click", ()=>{
      if (!STATE || !STATE.pub || !STATE.pub.kingWonder) return;
      if (phase === "mark"){
        if (!selectable && !KING_SELECTED.has(c.id)) return;
        if (KING_SELECTED.has(c.id)) KING_SELECTED.delete(c.id);
        else KING_SELECTED.add(c.id);
      } else {
        const p = kw.builder;
        const wm = STATE.pub.wonderMark[p];
        const cur = (wm && typeof wm.delta === "number") ? wm.delta : 0;
        wm.delta = (cur===-1) ? 0 : (cur===0 ? 1 : -1);
        syncKingOverlay();
        return;
      }

      // Re-render to apply button state
      syncKingOverlay();
    });

    return el;
  }

  if (phase === "mark"){
    const grouped = {S:[], C:[], H:[], D:[]};
    for (const c of sortedCards){
      if (!c || !grouped[c.suit]) continue;
      grouped[c.suit].push(c);
    }

    for (const s of ["S","C","H","D"]){
      const groupCards = grouped[s];
      if (!groupCards.length) continue;
      const box = document.createElement("div");
      box.className = "kingSuitGroup";

      const ttl = document.createElement("div");
      ttl.className = "kingSuitTitle";
      ttl.textContent = `${SUIT_ICON[s]} ${SUIT_NAME[s]}`;
      box.appendChild(ttl);

      const row = document.createElement("div");
      row.className = "kingSuitCards";
      for (const c of groupCards) row.appendChild(renderMiniCard(c));
      box.appendChild(row);
      elKingGrid.appendChild(box);
    }
  } else {
    for (const c of sortedCards) elKingGrid.appendChild(renderMiniCard(c));
  }

  if (phase === "mark"){
    btnKingConfirm.textContent = `Mark (${KING_SELECTED.size}/1)`;
    const ok = (KING_SELECTED.size === 1);
    btnKingConfirm.disabled = !ok;
    if (elKingErr){
      elKingErr.textContent = ok ? "" : "Select exactly 1 card to mark.";
    }
  } else {
    const wm = STATE?.pub?.wonderMark?.[kw.builder];
    const cur = (wm && typeof wm.delta === "number") ? wm.delta : 0;
    btnKingConfirm.textContent = `Confirm (${cur>=0?`+${cur}`:String(cur)})`;
    btnKingConfirm.disabled = false;
    if (elKingErr) elKingErr.textContent = "Click the marked card to cycle between -1 / 0 / +1, then press Confirm.";
  }
}

function logFinalize(res, beforeAge){
  if (!res) return;
  if (res.flipped>0) logLine(`${res.flipped} card(s) revealed.`);
  if (res.endedAge && beforeAge==="ancient"){
    logLine(`End of the Ancient Age. The Modern Age starts now: first player ${playerName(STATE.pub.currentPlayer)}.`);
    if (STATE.pub.modernSwapStillAvailable) logLine("Note: the Leader choice to change turn order is available to the second player (before any Modern pick).");
  }
  if (res.endedGame){
    logLine(`End of the Modern Age. Final score: Human ${STATE.pub.score.human} – AI ${STATE.pub.score.ai}.`);
  }
}

window.addEventListener("resize", ()=>{
  if (KING_OPEN) syncKingOverlay();
});

if (btnKingConfirm) btnKingConfirm.addEventListener("click", ()=>{
  if (!STATE || !STATE.pub || !STATE.pub.kingWonder) return;

  const kw = STATE.pub.kingWonder;
  const beforeAge = STATE.pub.age;

  if (kw.phase === "mark"){
    const ids = [...KING_SELECTED];
    const markedText = ids.map(id => cardLabel(_findCardById(id))).filter(Boolean).join(", ");
    const r = Engine.submitKingWonderOffer(STATE, ids);
    if (!r.ok){
      if (elKingErr) elKingErr.textContent = r.msg || "Invalid mark.";
      return;
    }
    logLine(`King Wonder: Human marks ${markedText || "(none)"}.`);
    logFinalize(r, beforeAge);
    render();
    maybeAIMove();
  } else {
    const p = kw.builder;
    const wm = STATE.pub.wonderMark[p];
    const cur = (wm && typeof wm.delta === "number") ? wm.delta : 0;
    const r = Engine.chooseKingWonder(STATE, cur);
    if (!r.ok){
      if (elKingErr) elKingErr.textContent = r.msg || "Invalid choice.";
      return;
    }
    const c = _findCardById(r.kingWonderCardId);
    logLine(`King Wonder: ${playerName(p)} final choice on ${cardLabel(c)} = ${r.kingWonderDelta>=0?`+${r.kingWonderDelta}`:String(r.kingWonderDelta)}.`);
    logFinalize(r, beforeAge);
    render();
    maybeAIMove();
  }
});


const elEnd = document.getElementById("endOverlay");
const elEndBody = document.getElementById("endBody");
const elEndScoreLine = document.getElementById("endScoreLine");
const btnEndClose = document.getElementById("endCloseBtn");
const btnEndNew = document.getElementById("endNewBtn");

let END_OPEN = false;
let END_SHOWN = false;

function openEndOverlay(){
  END_OPEN = true;
  elEnd.style.display = "flex";
}
function closeEndOverlay(){
  END_OPEN = false;
  elEnd.style.display = "none";
}

btnEndClose.addEventListener("click", ()=> closeEndOverlay());
btnEndNew.addEventListener("click", ()=>{
  closeEndOverlay();
  // trigger the existing New Game handler (does not alter engine logic)
  btnNew.click();
});

/* Build a readable score breakdown without touching the engine rules */
function culturePointsDetail(hCards, aCards, wonderMods=null){
  // Culture is CONTESTED: across both players there are only two award tiers:
  // - +10 to the best straight (len ≥ 2)
  // - +5 to the second-best straight (next distinct tier, len ≥ 2)
  // In case of a tie on (len, high card), the tier is shared.
  const res = cultureContestVP(hCards, aCards, wonderMods);

  const hTop = res.hRuns.slice(0,2);
  const aTop = res.aRuns.slice(0,2);

  function ownersLabel(group){
    if (!group || group.length===0) return "none";
    const owners = Array.from(new Set(group.map(g=>g.owner))).sort();
    if (owners.length===2) return "Human & AI (tie)";
    return owners[0]===0 ? "Human" : "AI";
  }
  function awardText(group, pts){
    if (!group || group.length===0) return `+${pts}: none`;
    return `+${pts}: ${ownersLabel(group)} (${runText(group[0].run)})`;
  }

  const reason = `♦ Culture VP (contested): ${awardText(res.bestGroup,10)}; ${awardText(res.secondGroup,5)}.`;

  return {
    h: res.h,
    a: res.a,
    hRuns: hTop,
    aRuns: aTop,
    bestGroup: res.bestGroup,
    secondGroup: res.secondGroup,
    reason
  };
}

function computeFinalBreakdown(){
  const pub = STATE.pub;
  const wonderMods = [0,1].map(p=>{
    const wm = pub.wonderMark?.[p] || {};
    return {cardId: wm.cardId || null, delta: Number(wm.delta)||0};
  });

  const allH = pub.taken[0].slice();
  const allA = pub.taken[1].slice();
  const hAnc = allH.filter(c=>c.age==="ancient");
  const aAnc = allA.filter(c=>c.age==="ancient");

  // Ancient (scored on Ancient-only cards)
  const ancHS = sumSuit(hAnc,"S", wonderMods);
  const ancAS = sumSuit(aAnc,"S", wonderMods);
  const ancMilH = (ancHS>ancAS) ? 4 : 0;
  const ancMilA = (ancAS>ancHS) ? 4 : 0;
  const ancPen5H = hasAllFourOfValue(hAnc,5) ? -3 : 0;
  const ancPen5A = hasAllFourOfValue(aAnc,5) ? -3 : 0;
  const ancTotalH = ancMilH + ancPen5H;
  const ancTotalA = ancMilA + ancPen5A;

  // Modern (scored on ALL collected cards, as per modernScoring())
  const modHS = sumSuit(allH,"S", wonderMods);
  const modAS = sumSuit(allA,"S", wonderMods);
  const modMilH = (modHS>modAS) ? 8 : 0;
  const modMilA = (modAS>modHS) ? 8 : 0;

  const modFoodH = foodPoints(allH, wonderMods);
  const modFoodA = foodPoints(allA, wonderMods);

  const cult = culturePointsDetail(allH, allA, wonderMods);

  const modTechH = techPoints(allH, wonderMods);
  const modTechA = techPoints(allA, wonderMods);

  const modPen10H = hasAllFourOfValue(allH,10) ? -6 : 0;
  const modPen10A = hasAllFourOfValue(allA,10) ? -6 : 0;

  const modTotalH = modMilH + modFoodH + cult.h + modTechH + modPen10H;
  const modTotalA = modMilA + modFoodA + cult.a + modTechA + modPen10A;

  const grandH = ancTotalH + modTotalH;
  const grandA = ancTotalA + modTotalA;

  return {
    ancient: {mil:{h:ancMilH,a:ancMilA,hs:ancHS,as:ancAS}, pen5:{h:ancPen5H,a:ancPen5A}, total:{h:ancTotalH,a:ancTotalA}},
    modern:  {mil:{h:modMilH,a:modMilA,hs:modHS,as:modAS}, food:{h:modFoodH,a:modFoodA,rawH:sumSuit(allH,"C", wonderMods),rawA:sumSuit(allA,"C", wonderMods)}, culture:{...cult}, tech:{h:modTechH,a:modTechA}, pen10:{h:modPen10H,a:modPen10A}, total:{h:modTotalH,a:modTotalA}},
    grand: {h:grandH,a:grandA}
  };
}

function fmtPts(x){ return (x>0?`+${x}`: String(x)); }
function safeNum(x){ return (typeof x==="number" && isFinite(x)) ? x : 0; }

function renderEndOverlay(){
  const bd = computeFinalBreakdown();
  const h = safeNum(bd.grand.h);
  const a = safeNum(bd.grand.a);

  let winner = "Draw";
  if (h>a) winner = "Human";
  else if (a>h) winner = "AI";
  else {
    const tieOwner = wonderTieOwner(STATE.pub.taken[0], STATE.pub.taken[1]);
    if (tieOwner===0) winner = "Human";
    else if (tieOwner===1) winner = "AI";
  }

  elEndScoreLine.textContent = `Final: Human ${h} – AI ${a} (${winner})`;

  const anc = bd.ancient, mod = bd.modern;

  const hBest = (mod.culture.hRuns && mod.culture.hRuns[0]) ? runText(mod.culture.hRuns[0]) : "—";
  const hSecond = (mod.culture.hRuns && mod.culture.hRuns[1]) ? runText(mod.culture.hRuns[1]) : "";
  const aBest = (mod.culture.aRuns && mod.culture.aRuns[0]) ? runText(mod.culture.aRuns[0]) : "—";
  const aSecond = (mod.culture.aRuns && mod.culture.aRuns[1]) ? runText(mod.culture.aRuns[1]) : "";

  function ownersLabel(group){
    if (!group || group.length===0) return "none";
    const owners = Array.from(new Set(group.map(g=>g.owner))).sort();
    if (owners.length===2) return "Human & AI (tie)";
    return owners[0]===0 ? "Human" : "AI";
  }
  function awardText(group, pts){
    if (!group || group.length===0) return `+${pts}: none`;
    return `+${pts}: ${ownersLabel(group)} (${runText(group[0].run)})`;
  }

  const cultureLine = `Human ${fmtPts(mod.culture.h)} VP (best: ${hBest}${hSecond ? "; second: " + hSecond : ""}) • AI ${fmtPts(mod.culture.a)} VP (best: ${aBest}${aSecond ? "; second: " + aSecond : ""}) — ${awardText(mod.culture.bestGroup,10)}; ${awardText(mod.culture.secondGroup,5)}`;
  elEndBody.innerHTML = `
    <div style="display:grid; grid-template-columns: 1fr; gap:10px;">
      <div class="box" style="background: rgba(0,0,0,.16);">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
          <div style="font-weight:700;">Ancient Age</div>
          <div class="pill" style="border-color: rgba(56,189,248,.28); color: rgba(56,189,248,.92);">Subtotal: Human ${anc.total.h} – AI ${anc.total.a}</div>
        </div>
        <div style="margin-top:8px; display:grid; gap:6px;">
          <div>♠ Military: Human ${anc.mil.hs} vs AI ${anc.mil.as} — Human ${fmtPts(anc.mil.h)} PV • AI ${fmtPts(anc.mil.a)} PV</div>
          <div>❺ Minor Calamity: Human ${fmtPts(anc.pen5.h)} PV • AI ${fmtPts(anc.pen5.a)} PV</div>
        </div>
      </div>

      <div class="box" style="background: rgba(0,0,0,.16);">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
          <div style="font-weight:700;">Modern Age</div>
          <div class="pill" style="border-color: rgba(56,189,248,.28); color: rgba(56,189,248,.92);">Subtotal: Human ${mod.total.h} – AI ${mod.total.a}</div>
        </div>

        <div style="margin-top:8px; display:grid; gap:6px;">
          <div>♠ Military: Human ${mod.mil.hs} vs AI ${mod.mil.as} — Human ${fmtPts(mod.mil.h)} PV • AI ${fmtPts(mod.mil.a)} PV</div>
          <div>♣ Food: (totals: Human ${mod.food.rawH} vs AI ${mod.food.rawA}) — Human ${fmtPts(mod.food.h)} PV • AI ${fmtPts(mod.food.a)} PV</div>
          <div>♦ Culture: — ${cultureLine}</div>
<div>♥ Technology: Human ${fmtPts(mod.tech.h)} PV • AI ${fmtPts(mod.tech.a)} PV</div>
          <div>❿ Major Calamity: Human ${fmtPts(mod.pen10.h)} PV • AI ${fmtPts(mod.pen10.a)} PV</div>
        </div>
      </div>

      <div class="box" style="background: rgba(0,0,0,.16);">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
          <div style="font-weight:750;">Total</div>
          <div class="pill ok" style="border-color: rgba(34,197,94,.35); color: rgba(34,197,94,.92);">Human ${h}</div>
          <div class="pill warn" style="border-color: rgba(245,158,11,.35); color: rgba(245,158,11,.92);">AI ${a}</div>
        </div>
      </div>
    </div>
  `;
}

/* Close end overlay with Escape */
document.addEventListener("keydown", (e)=>{
  if (e.key==="Escape" && END_OPEN) closeEndOverlay();
});


/* === Tableau auto-fit (keeps the full grid visible without scrolling) === */
let _fitRaf = 0;
function scheduleFitTableau(){
  if (_fitRaf) cancelAnimationFrame(_fitRaf);
  _fitRaf = requestAnimationFrame(() => { _fitRaf = 0; fitTableau(); });
}

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

function fitTableau(){
  try{
    if (!elTableau) return;
    const bd = elTableau.parentElement; // .bd
    if (!bd) return;

    // Available space inside the tableau panel body (content box, excluding padding)
    const bdStyle = getComputedStyle(bd);
    const padX = (parseFloat(bdStyle.paddingLeft)||0) + (parseFloat(bdStyle.paddingRight)||0);
    const padY = (parseFloat(bdStyle.paddingTop)||0) + (parseFloat(bdStyle.paddingBottom)||0);

    let availW = bd.clientWidth - padX;
    let availH = bd.clientHeight - padY;

    // Subtract the <details> block if visible (desktop)
    const det = bd.querySelector("details");
    if (det && getComputedStyle(det).display !== "none"){
      const r = det.getBoundingClientRect();
      // +8px to account for the inline margin-top used in markup
      availH -= (r.height + 8);
    }

    // Subtract tableau's own vertical padding
    const tStyle = getComputedStyle(elTableau);
    const tPadY = (parseFloat(tStyle.paddingTop)||0) + (parseFloat(tStyle.paddingBottom)||0);
    availH -= tPadY;

    // Safety
    availW = Math.max(1, availW);
    availH = Math.max(1, availH);

    const layout = (typeof STATE !== "undefined" && STATE && STATE.pub) ? layoutForAge(STATE.pub.age) : layoutForAge("ancient");
    const rows = layout.rows.length;
    const maxCols = Math.max(...layout.rows.map(r => r.length));
    if (!rows) return;

    // Base gaps (we will scale them with the card size)
    const baseColGap = 8;
    const baseRowGap = 6;

    // Card aspect ratio (height/width)
    const ratio = 96/72;

    // First pass: estimate card width with base gaps
    const wByWidth_1 = (availW - (maxCols - 1) * baseColGap) / maxCols;
    const hByHeight_1 = (availH - (rows - 1) * baseRowGap) / rows;
    const wByHeight_1 = hByHeight_1 / ratio;

    let cardW = Math.floor(Math.min(wByWidth_1, wByHeight_1));
    // Keep it usable but allow shrinking for tiny screens.
    // Max size scales slightly with viewport width (more relative to device size).
    const viewportW = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    const maxCardW = (viewportW <= 420) ? 92 : (viewportW <= 540 ? 96 : 94);
    cardW = clamp(cardW, 38, maxCardW);

    // Scale gaps with the card size, then recompute with scaled gaps
    const scale = clamp(cardW / 72, 0.55, 1.15);
    const colGap = Math.round(baseColGap * scale);
    const rowGap = Math.round(baseRowGap * scale);

    const wByWidth_2 = (availW - (maxCols - 1) * colGap) / maxCols;
    const hByHeight_2 = (availH - (rows - 1) * rowGap) / rows;
    const wByHeight_2 = hByHeight_2 / ratio;

    cardW = Math.floor(Math.min(wByWidth_2, wByHeight_2));
    cardW = clamp(cardW, 38, maxCardW);

    const cardH = Math.round(cardW * ratio);
    const rad = clamp(Math.round(cardW * 0.19), 10, 18);

    const root = document.documentElement;
    root.style.setProperty("--cardW", `${cardW}px`);
    root.style.setProperty("--cardH", `${cardH}px`);
    root.style.setProperty("--cardRad", `${rad}px`);
    root.style.setProperty("--colGap", `${colGap}px`);
    root.style.setProperty("--rowGap", `${rowGap}px`);
  }catch(e){
    // Never break the game UI because of fitting logic
    // (keep silent; debugging can be done via DevTools)
  }
}

// React to viewport changes (mobile address bar/orientation) and first paint
window.addEventListener("resize", scheduleFitTableau, {passive:true});
if (window.visualViewport){
  window.visualViewport.addEventListener("resize", scheduleFitTableau, {passive:true});
}
document.addEventListener("fullscreenchange", scheduleFitTableau);



function playerName(p){ return p===0 ? "Human" : "AI"; }
function cardLabel(card){
  if (!card) return "??";
  if (card.kind==="king") return "K" + SUIT_ICON[card.suit];
  const v = (card.value===1) ? "A" : String(card.value);
  return v + SUIT_ICON[card.suit];
}
function shortCardLabel(card){
  if (!card) return "??";
  if (card.kind==="king") return "K" + SUIT_ICON[card.suit];
  const v = (card.value===1) ? "A" : String(card.value);
  return v + SUIT_ICON[card.suit];
}
function clearLog(){ elLog.textContent=""; }
function logLine(s){ elLog.textContent += s + "\n"; elLog.scrollTop = elLog.scrollHeight; }

const btnLogOpen = document.getElementById("logOpenBtn");
const btnLogClose = document.getElementById("logCloseBtn");
const elLogBackdrop = document.getElementById("logBackdrop");

function openLogOverlay(){
  document.body.classList.add("logOpen");
}
function closeLogOverlay(){
  document.body.classList.remove("logOpen");
}

if (btnLogOpen) btnLogOpen.addEventListener("click", ()=> openLogOverlay());
if (btnLogClose) btnLogClose.addEventListener("click", ()=> closeLogOverlay());
if (elLogBackdrop) elLogBackdrop.addEventListener("click", ()=> closeLogOverlay());

document.addEventListener("keydown", (e)=>{
  if (e.key==="Escape" && document.body.classList.contains("logOpen")) closeLogOverlay();
});

function shouldPromptModernWonder(){
  if (!STATE) return false;
  if (STATE.pub && STATE.pub.kingWonder) return false;
  return Engine.canUseModernSwap(STATE.pub, 0);
}


btnModalYes.addEventListener("click", ()=>{
  if (!STATE) return;
  const r = Engine.useModernSwap(STATE, 0);
  if (r.ok) logLine("Human discards the Leader to become first in the Modern Age.");
  else logLine("Leader: " + r.msg);
  closeModal();
  render();
});

btnModalNo.addEventListener("click", ()=>{
  if (!STATE) return;
  // decline: the choice window closes and the normal Modern Age continues
  STATE.pub.modernSwapStillAvailable = false;
  closeModal();
  logLine("Choice: you are not discarding the Leader now (order unchanged).");
  render();
  maybeAIMove();
});

btnNew.addEventListener("click", ()=>{
  const starter = document.getElementById("whoStarts").value;
  STATE = Engine.newGame(starter);
  END_SHOWN = false; closeEndOverlay(); closeLogOverlay();
  clearLog();
  logLine(`New game. Starting: ${playerName(STATE.pub.currentPlayer)}.`);
  render();
  maybeAIMove();
});

btnWonder.addEventListener("click", ()=>{
  if (!STATE) return;
  if (STATE.pub.ended) return;
  if (MODAL_OPEN) return;

  const r = Engine.useJokerDouble(STATE);
  if (!r.ok) logLine("Leader: " + r.msg);
  else logLine("Human uses the Leader: 2 picks this turn.");
  render();
  maybeAIMove();
});

if (btnWonderSide) btnWonderSide.addEventListener("click", ()=>{ if (btnWonder) btnWonder.click(); });

function summarize(cards){
  const s = sumSuit(cards,"S");
  const d = bestDiamondStraight(cards);
  const c = sumSuit(cards,"C");
  const h = techPoints(cards);
  const five = countValue(cards,5);
  const ten = countValue(cards,10);
  return `Total ${cards.length} | ♠ ${s} | ♣ ${c} | ♦ best ${Math.max(0,(d.len>=2?d.len:0))} (high ${d.maxCard}) | ♥ ${h} | 5=${five} | 10=${ten}`;
}


function runTokens(values, dashMinLen, vpSelector=null){
  const set = new Set(values);
  const runs = circularRuns(set);

  const groupRuns = runs.filter(r => r.len >= dashMinLen);

  const inGroup = new Set();
  for(const r of groupRuns){ for(const v of r.cards) inGroup.add(v); }

  const vpKeys = new Set();
  if (vpSelector instanceof Set){
    for (const k of vpSelector) vpKeys.add(k);
  } else if (typeof vpSelector === "number"){
    const ranked = groupRuns.slice().sort((a,b)=> (b.len-a.len) || (b.maxCard-a.maxCard));
    for(const r of ranked.slice(0, vpSelector)) vpKeys.add(r.cards.join(","));
  } else if (vpSelector === true){
    for(const r of groupRuns) vpKeys.add(r.cards.join(","));
  }

  const singles = [...set]
    .filter(v => !inGroup.has(v))
    .sort((a,b)=>a-b)
    .map(v => ({ key: v, text: valueLabel(v), vp: false }));

  const groups = groupRuns
    .slice()
    .sort((a,b)=> (a.cards[0]-b.cards[0]))
    .map(r => ({
      key: r.cards[0],
      text: r.cards.map(valueLabel).join("-"),
      vp: vpKeys.has(r.cards.join(","))
    }));

  return singles.concat(groups).sort((a,b)=>a.key-b.key);
}

function renderHands(){
  const pub = STATE.pub;
  const h = pub.taken[0];
  const a = pub.taken[1];

  elCompareBody.innerHTML = "";

  const cult = cultureContestVP(h, a);
  const hCultKeys = new Set();
  const aCultKeys = new Set();
  for (const g of (cult.bestGroup||[])){
    const k = (g.run && g.run.cards) ? g.run.cards.join(",") : "";
    if (!k) continue;
    if (g.owner===0) hCultKeys.add(k);
    if (g.owner===1) aCultKeys.add(k);
  }
  for (const g of (cult.secondGroup||[])){
    const k = (g.run && g.run.cards) ? g.run.cards.join(",") : "";
    if (!k) continue;
    if (g.owner===0) hCultKeys.add(k);
    if (g.owner===1) aCultKeys.add(k);
  }

  function bestTechKey(cards){
    const vals = suitValues(cards,"H");
    const runs = circularRuns(new Set(vals)).filter(r=>r.len>=3);
    runs.sort((a,b)=> (b.len-a.len) || (b.maxCard-a.maxCard));
    return (runs[0] && runs[0].cards) ? runs[0].cards.join(",") : "";
  }

  const hTechKey = bestTechKey(h);
  const aTechKey = bestTechKey(a);

  const addChip = (parent, text, opts={}) => {
    const vp = !!opts.vp;
    const marked = !!opts.marked;
    const chip = document.createElement("div");
    chip.className = vp ? "chip vp" : "chip";
    if (marked) chip.classList.add("marked");
    chip.textContent = text;
    parent.appendChild(chip);
  };

  const buildSuitData = (cards, suit, isHuman) => {
    const wm = pub.wonderMark?.[isHuman ? 0 : 1];
    const markedCard = wm && wm.cardId ? cards.find(c=>c && c.id===wm.cardId) : null;

    if (suit === "S"){
      const vals = suitValues(cards,"S");
      const total = sumSuit(cards,"S");
      return { score: total, headline: String(total), chips: vals.map(valueLabel), markedCard };
    }
    if (suit === "C"){
      const vals = suitValues(cards,"C");
      const total = sumSuit(cards,"C");
      const vp = Math.floor(total/5);
      return { score: total, headline: `${total} (${vp} VP)`, chips: vals.map(valueLabel), markedCard };
    }
    if (suit === "H"){
      const vals = suitValues(cards,"H");
      const key = isHuman ? hTechKey : aTechKey;
      const tokens = runTokens(vals, 3, key ? new Set([key]) : null);
      return { tokens, markedCard };
    }

    const vals = suitValues(cards,"D");
    const vpKeys = isHuman ? hCultKeys : aCultKeys;
    const tokens = runTokens(vals, 2, (vpKeys && vpKeys.size) ? vpKeys : null);
    return { tokens, markedCard };
  };

  const renderBattleCell = (td, own, suit) => {
    const cell = document.createElement("div");
    cell.className = "battleCell";

    if (own.headline){
      const head = document.createElement("div");
      head.className = "battleHead";
      const value = document.createElement("div");
      value.className = "battleValue";
      value.textContent = own.headline;
      head.appendChild(value);
      cell.appendChild(head);
    }

    const values = document.createElement("div");
    values.className = "suitValues";
    if (own.tokens){
      if (own.tokens.length===0) addChip(values, "—");
      else for (const t of own.tokens) addChip(values, t.text, {vp:t.vp});
    } else {
      const chips = own.chips || [];
      if (chips.length===0) addChip(values, "—");
      else for (const c of chips) addChip(values, c);
    }

    if (own.markedCard && own.markedCard.suit === suit){
      const wm = pub.wonderMark?.[own===hData[suit] ? 0 : 1];
      const deltaVal = (typeof wm?.delta === "number") ? wm.delta : 0;
      const deltaText = deltaVal===0 ? "0" : (deltaVal>0 ? `+${deltaVal}` : String(deltaVal));
      const stateText = wm?.finalChoicePending ? "pending" : `final ${deltaText}`;
      addChip(values, `★ ${cardLabel(own.markedCard)} (${stateText})`, {marked:true});
    }

    cell.appendChild(values);
    td.appendChild(cell);
  };

  const suits = [
    { key:"S", label:"♠ Military", cls:"suitS" },
    { key:"C", label:"♣ Food", cls:"suitC" },
    { key:"H", label:"♥ Technology", cls:"suitH" },
    { key:"D", label:"♦ Culture", cls:"suitD" }
  ];

  const hData = {};
  const aData = {};
  for (const s of suits){
    hData[s.key] = buildSuitData(h, s.key, true);
    aData[s.key] = buildSuitData(a, s.key, false);
  }

  for (const s of suits){
    const tr = document.createElement("tr");
    tr.className = `compareRow ${s.cls}`;

    const labelTd = document.createElement("td");
    const cat = document.createElement("div");
    cat.className = `catCell ${s.cls}`;
    cat.textContent = s.label;
    labelTd.appendChild(cat);

    const humanTd = document.createElement("td");
    renderBattleCell(humanTd, hData[s.key], s.key);

    const aiTd = document.createElement("td");
    renderBattleCell(aiTd, aData[s.key], s.key);

    tr.appendChild(labelTd);
    tr.appendChild(humanTd);
    tr.appendChild(aiTd);
    elCompareBody.appendChild(tr);
  }

  const tr = document.createElement("tr");
  tr.className = "compareRow wonders";
  const labelTd = document.createElement("td");
  const cat = document.createElement("div");
  cat.className = "catCell wonders";
  cat.textContent = "K Wonders";
  labelTd.appendChild(cat);

  const humanTd = document.createElement("td");
  const aiTd = document.createElement("td");

  const buildWondersCell = (td, cards) => {
    const cell = document.createElement("div");
    cell.className = "battleCell";
    const kings = cards.filter(c=>c && c.kind==="king");

    const values = document.createElement("div");
    values.className = "suitValues";
    if (kings.length===0) addChip(values, "—");
    else {
      const order = {S:0, D:1, H:2, C:3};
      kings.sort((x,y)=> (order[x.suit]-order[y.suit]));
      for (const k of kings) addChip(values, cardLabel(k));
    }
    cell.appendChild(values);
    td.appendChild(cell);
  };

  buildWondersCell(humanTd, h);
  buildWondersCell(aiTd, a);
  tr.appendChild(labelTd);
  tr.appendChild(humanTd);
  tr.appendChild(aiTd);
  elCompareBody.appendChild(tr);
}

function render(){
  // Layout mode: hide the top header while a game is in progress.
  const _playing = !!(STATE && STATE.pub && !STATE.pub.ended);
  document.body.classList.toggle("playing", _playing);

  if (!STATE){
    elStatusLine.textContent="Press “New game”.";
    elTableau.innerHTML="";
    if (elCompareBody) elCompareBody.innerHTML = "";
    if (btnWonderSide) btnWonderSide.disabled = true;
    return;
  }
  const pub = STATE.pub;

  syncKingOverlay();

  if (!MODAL_OPEN && shouldPromptModernWonder()) {
    openModal();
  }

  // AI pre-Modern choice (symmetry): if the AI is the second player in Modern and the window is open, it decides now (before any Modern pick).
  if (!MODAL_OPEN && Engine.canUseModernSwap(pub, 1)) {
    // Simple heuristic: use the swap if behind on points, or if the level is MonteCarlo.
    const behind = (pub.score.ai < pub.score.human);
    const isMC = (document.getElementById("aiLevel")?.value === "mc");
    if (behind || isMC) {
      const r = Engine.useModernSwap(STATE, 1);
      if (r.ok) logLine("AI discards the Leader to become first in the Modern Age.");
    }
    // In any case we close the window: the moment has passed.
    pub.modernSwapStillAvailable = false;
  }


  elAgePill.textContent = (pub.age==="ancient") ? "Ancient Age" : "Modern Age";
  elTurnPill.textContent = "Turn: " + playerName(pub.currentPlayer);
  elTurnPill.classList.toggle("turn-ai", pub.currentPlayer===1 && !pub.ended);
  elActionPill.textContent = "Picks left: " + pub.picksLeftThisTurn;
  elScorePill.textContent = `Score: Human ${pub.score.human} VP – AI ${pub.score.ai} VP`;

  // End-of-game UI (presentation only)
  if (pub.ended && !END_SHOWN){
    END_SHOWN = true;
    closeLogOverlay();
    renderEndOverlay();
    openEndOverlay();
  }

  const remaining = pub.slots.filter(s=>!s.removed).length;
  const jokerH = pub.jokerUsed[0] ? "used" : "available";
  const jokerA = pub.jokerUsed[1] ? "used" : "available";
  const swap = (pub.age==="modern" && pub.modernSwapStillAvailable) ? "Leader choice (turn order) available" : "Leader choice (turn order) n/a";

  elStatusLine.innerHTML = `
    <span class="pill">Cards left: ${remaining}</span>
    <span class="pill">Human Leader: ${jokerH}</span>
    <span class="pill">AI Leader: ${jokerA}</span>
    <span class="pill">${swap}</span>
  `;


  // Wonder (effect: 2 picks this turn)
  btnWonder.disabled = pub.ended || pub.currentPlayer!==0 || ( !Engine.canUseJokerDouble(pub,0) );
  if (btnWonderSide) btnWonderSide.disabled = btnWonder.disabled;

  // tableau render (ordine visivo dal layout ufficiale)
  // Importantissimo: aggiorna prima le CSS vars (cardW/cardH/colGap) e poi calcola la geometria
  const layout = layoutForAge(pub.age);
  fitTableau();
  
  const _metrics = getTableauMetrics();
  const TABLEAU_GEOM = computeTableauGeometry(_metrics, layout);
  
  elTableau.innerHTML="";
  elTableau.style.width = TABLEAU_GEOM.width + "px";
  elTableau.style.height = TABLEAU_GEOM.height + "px";
  const showIdx = cbDebug.checked;

  for(const row of layout.rows){
    for(const idx of row){
      const s = pub.slots[idx];

      const el = document.createElement("div");
      el.className="card";
      if (!s.removed) el.classList.add("clickable");
      if (s.removed) el.classList.add("removed");
      if (s.faceDown && !s.removed) el.classList.add("faceDown");

      if (!s.removed && !s.faceDown && s.card && s.card.suit){
        el.classList.add("suit" + s.card.suit);
      }


      const accessible = (!s.removed && !s.faceDown && Engine.isAccessible(pub, idx));
      if (accessible) el.classList.add("accessible");
      const blocked = (!s.removed && !s.faceDown && !accessible);
      if (blocked) el.classList.add("blocked");

      const big = document.createElement("div");
      big.className="big";
      big.textContent = s.removed ? "" : (s.faceDown ? "" : cardLabel(s.card));

      const small = document.createElement("div");
      small.className="small";
      small.textContent = s.removed ? "" : (s.faceDown ? "" : (s.card && s.card.kind==="king" ? "WONDER" : (SUIT_ABBR[s.card.suit] || SUIT_NAME[s.card.suit] || "")));

      const cornerL = document.createElement("div");
      cornerL.className="cornerL";
      cornerL.textContent = (showIdx && !s.removed) ? String(idx) : "";

      el.appendChild(big);
      el.appendChild(cornerL);
      el.appendChild(small);

      el.addEventListener("click", ()=>{
        if (MODAL_OPEN) return;
        if (!STATE) return;
        if (STATE.pub.kingWonder) return;
        if (STATE.pub.currentPlayer!==0) return;
        if (STATE.pub.ended) return;
        if (s.removed || s.faceDown) return;
        if (!Engine.isAccessible(STATE.pub, idx)) return;

        const beforeAge = STATE.pub.age;
        const r = Engine.take(STATE, idx);
        if (!r.ok){ logLine(r.msg); render(); return; }

        logLine(`Human takes ${cardLabel(s.card)}.`);

        if (r.pendingKingWonder){
          const kw = STATE.pub.kingWonder;
          if (kw){
            if (kw.phase==="finalChoice"){
              logLine(`King Wonder: ${playerName(kw.builder)} chooses final value for the marked card (-1/0/+1).`);
            } else {
              logLine(`King Wonder: ${playerName(kw.builder)} must mark 1 own non-King card.`);
            }
          }
        } else {
          if (r.flipped>0) logLine(`${r.flipped} card(s) revealed.`);

          if (r.endedAge && beforeAge==="ancient"){
            logLine(`End of the Ancient Age. The Modern Age starts now: first player ${playerName(STATE.pub.currentPlayer)}.`);
            if (STATE.pub.modernSwapStillAvailable) logLine("Note: the Leader choice to change turn order is available to the second player (before any Modern pick).");
          }
          if (r.endedGame){
            logLine(`End of the Modern Age. Final score: Human ${STATE.pub.score.human} – AI ${STATE.pub.score.ai}.`);
          }
        }

        render();
        maybeAIMove();
      });

      const p = TABLEAU_GEOM.pos[idx] || {x:0,y:0,row:0,col:0};
      el.style.left = p.x + "px";
      el.style.top = p.y + "px";
		const z = (p.row || 0) * 10 + (p.col || 0) + (accessible ? 100 : 0);
		el.style.zIndex = String(z);

      elTableau.appendChild(el);
    }
  }

  renderHands();
}

function maybeAIMove(){
  if (!STATE) return;
  if (STATE.pub.ended) return;
  if (STATE.pub.kingWonder) return;
  if (MODAL_OPEN || shouldPromptModernWonder()) return;
  if (STATE.pub.currentPlayer!==1) return;

  setTimeout(()=>{
    if (!STATE || STATE.pub.ended || STATE.pub.currentPlayer!==1) return;

    const mv = aiChoose(STATE);

    if (mv.type==="modernSwap"){
      const r = Engine.useModernSwap(STATE, 1);
      if (r.ok) logLine("AI discards the Leader to become first in the Modern Age.");
      render();
      // continue (AI may have the next move if it is now first and it is still its turn)
      maybeAIMove();
      return;
    }

    if (mv.type==="wonder"){
      const r = Engine.useJokerDouble(STATE);
      if (r.ok) logLine("AI uses the Leader: 2 picks this turn.");
      render();
      maybeAIMove();
      return;
    }

    if (mv.type==="take"){
      const sl = STATE.pub.slots[mv.idx];
      const beforeAge = STATE.pub.age;
      const r = Engine.take(STATE, mv.idx);
      if (r.ok){
        logLine(`AI takes ${cardLabel(sl.card)}.`);

        if (r.pendingKingWonder){
          const kw = STATE.pub.kingWonder;
          if (kw){
            if (kw.phase==="finalChoice") logLine(`King Wonder: ${playerName(kw.builder)} chooses final value for the marked card (-1/0/+1).`);
            else logLine(`King Wonder: ${playerName(kw.builder)} must mark 1 own non-King card.`);
          }
        } else {
          if (r.flipped>0) logLine(`${r.flipped} card(s) revealed.`);
          if (r.endedAge && beforeAge==="ancient"){
            logLine(`End of the Ancient Age. The Modern Age starts now: first player ${playerName(STATE.pub.currentPlayer)}.`);
          }
          if (r.endedGame){
            logLine(`End of the Modern Age. Final score: Human ${STATE.pub.score.human} – AI ${STATE.pub.score.ai}.`);
          }
        }
      } else {
        logLine("AI: " + r.msg);
      }
      render();
      // se AI ha ancora una presa (Joker), continua
      if (STATE.pub.currentPlayer===1) maybeAIMove();
      return;
    }

    if (mv.type==="kingMark"){
      const r = Engine.submitKingWonderOffer(STATE, [mv.id]);
      if (!r.ok) logLine("AI (Wonder): " + r.msg);
      render();
      if (STATE.pub.currentPlayer===1) maybeAIMove();
      return;
    }

    if (mv.type==="kingDelta"){
      const r = Engine.chooseKingWonder(STATE, mv.delta, true);
      if (!r.ok) logLine("AI (Wonder): " + r.msg);
      render();
      if (STATE.pub.currentPlayer===1) maybeAIMove();
      return;
    }

    if (mv.type==="pass"){
      STATE.pub.picksLeftThisTurn = 1;
      STATE.pub.currentPlayer = 0;
      logLine("AI passes (no legal actions). Turn to Human.");
      render();
      return;
    }
  }, 120);
}

// init
STATE = Engine.newGame("human");
clearLog();
logLine("Ready. Press “New game” to start with the selected settings.");
render();
scheduleFitTableau();


</script>

</body>
</html>
